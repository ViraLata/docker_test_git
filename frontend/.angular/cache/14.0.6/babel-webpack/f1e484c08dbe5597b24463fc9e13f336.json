{"ast":null,"code":"import _getIterator from 'babel-runtime/core-js/get-iterator';\nimport _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport _createClass from 'babel-runtime/helpers/createClass'; // This is an enhanced port of Google Android `libphonenumber`'s\n// `asyoutypeformatter.js` of 17th November, 2016.\n//\n// https://github.com/googlei18n/libphonenumber/blob/8d21a365061de2ba0675c878a710a7b24f74d2ae/javascript/i18n/phonenumbers/asyoutypeformatter.js\n\nimport { get_phone_code, get_national_prefix, get_national_prefix_for_parsing, get_formats, get_format_pattern, get_format_format as _get_format_format, get_format_international_format, get_format_national_prefix_formatting_rule, get_format_national_prefix_is_mandatory_when_formatting, get_format_leading_digits_patterns, get_format_uses_national_prefix, get_metadata_by_country_phone_code } from './metadata';\nimport { VALID_PUNCTUATION, PLUS_CHARS, VALID_DIGITS, extract_formatted_phone_number, parse_phone_number, parse_phone_number_and_country_phone_code, find_country_code, strip_national_prefix } from './parse';\nimport { FIRST_GROUP_PATTERN, format_national_number_using_format, local_to_international_style } from './format';\nimport { matches_entirely } from './common'; // Used in phone number format template creation.\n// Could be any digit, I guess.\n\nvar DUMMY_DIGIT = '9';\nvar DUMMY_DIGIT_MATCHER = new RegExp(DUMMY_DIGIT, 'g'); // I don't know why is it exactly `15`\n\nvar LONGEST_NATIONAL_PHONE_NUMBER_LENGTH = 15; // Create a phone number consisting only of the digit 9 that matches the\n// `number_pattern` by applying the pattern to the \"longest phone number\" string.\n\nvar LONGEST_DUMMY_PHONE_NUMBER = repeat(DUMMY_DIGIT, LONGEST_NATIONAL_PHONE_NUMBER_LENGTH); // The digits that have not been entered yet will be represented by a \\u2008,\n// the punctuation space.\n\nexport var DIGIT_PLACEHOLDER = 'x'; // '\\u2008' (punctuation space)\n\nvar DIGIT_PLACEHOLDER_MATCHER = new RegExp(DIGIT_PLACEHOLDER);\nvar DIGIT_PLACEHOLDER_MATCHER_GLOBAL = new RegExp(DIGIT_PLACEHOLDER, 'g'); // A pattern that is used to match character classes in regular expressions.\n// An example of a character class is \"[1-4]\".\n\nvar CHARACTER_CLASS_PATTERN = /\\[([^\\[\\]])*\\]/g; // Any digit in a regular expression that actually denotes a digit. For\n// example, in the regular expression \"80[0-2]\\d{6,10}\", the first 2 digits\n// (8 and 0) are standalone digits, but the rest are not.\n// Two look-aheads are needed because the number following \\\\d could be a\n// two-digit number, since the phone number can be as long as 15 digits.\n\nvar STANDALONE_DIGIT_PATTERN = /\\d(?=[^,}][^,}])/g; // A pattern that is used to determine if a `format` is eligible\n// to be used by the \"as you type formatter\".\n// It is eligible when the `format` contains groups of the dollar sign\n// followed by a single digit, separated by valid phone number punctuation.\n// This prevents invalid punctuation (such as the star sign in Israeli star numbers)\n// getting into the output of the \"as you type formatter\".\n\nvar ELIGIBLE_FORMAT_PATTERN = new RegExp('^' + '[' + VALID_PUNCTUATION + ']*' + '(\\\\$\\\\d[' + VALID_PUNCTUATION + ']*)+' + '$'); // This is the minimum length of the leading digits of a phone number\n// to guarantee the first \"leading digits pattern\" for a phone number format\n// to be preemptive.\n\nvar MIN_LEADING_DIGITS_LENGTH = 3;\nvar VALID_INCOMPLETE_PHONE_NUMBER = '[' + PLUS_CHARS + ']{0,1}' + '[' + VALID_PUNCTUATION + VALID_DIGITS + ']*';\nvar VALID_INCOMPLETE_PHONE_NUMBER_PATTERN = new RegExp('^' + VALID_INCOMPLETE_PHONE_NUMBER + '$', 'i');\n\nvar as_you_type = function () {\n  function as_you_type(country_code, metadata) {\n    _classCallCheck(this, as_you_type); // Metadata is required.\n\n\n    if (!metadata || !metadata.countries) {\n      throw new Error('Metadata is required');\n    }\n\n    if (country_code && metadata.countries[country_code]) {\n      this.default_country = country_code;\n    }\n\n    this.metadata = metadata;\n    this.reset();\n  }\n\n  _createClass(as_you_type, [{\n    key: 'input',\n    value: function input(text) {\n      // Parse input\n      var extracted_number = extract_formatted_phone_number(text); // Special case for a lone '+' sign\n      // since it's not considered a possible phone number.\n\n      if (!extracted_number) {\n        if (text && text.indexOf('+') >= 0) {\n          extracted_number = '+';\n        }\n      } // Validate possible first part of a phone number\n\n\n      if (!matches_entirely(extracted_number, VALID_INCOMPLETE_PHONE_NUMBER_PATTERN)) {\n        return this.current_output;\n      }\n\n      return this.process_input(parse_phone_number(extracted_number));\n    }\n  }, {\n    key: 'process_input',\n    value: function process_input(input) {\n      // If an out of position '+' sign detected\n      // (or a second '+' sign),\n      // then just drop it from the input.\n      if (input[0] === '+') {\n        if (!this.parsed_input) {\n          this.parsed_input += '+'; // If a default country was set\n          // then reset it because an explicitly international\n          // phone number is being entered\n\n          this.reset_countriness();\n        }\n\n        input = input.slice(1);\n      } // Raw phone number\n\n\n      this.parsed_input += input; // // Reset phone number validation state\n      // this.valid = false\n      // Add digits to the national number\n\n      this.national_number += input; // Try to format the parsed input\n\n      if (this.is_international()) {\n        if (!this.country_phone_code) {\n          // If one looks at country phone codes\n          // then he can notice that no one country phone code\n          // is ever a (leftmost) substring of another country phone code.\n          // So if a valid country code is extracted so far\n          // then it means that this is the country code.\n          // If no country phone code could be extracted so far,\n          // then just return the raw phone number,\n          // because it has no way of knowing\n          // how to format the phone number so far.\n          if (!this.extract_country_phone_code()) {\n            // Return raw phone number\n            return this.parsed_input;\n          } // Initialize country-specific data\n\n\n          this.initialize_phone_number_formats_for_this_country_phone_code();\n          this.reset_format();\n          this.determine_the_country();\n        } // `this.country` could be `undefined`,\n        // for instance, when there is ambiguity\n        // in a form of several different countries\n        // each corresponding to the same country phone code\n        // (e.g. NANPA: USA, Canada, etc),\n        // and there's not enough digits entered\n        // to reliably determine the country\n        // the phone number belongs to.\n        // Therefore, in cases of such ambiguity,\n        // each time something is input,\n        // try to determine the country\n        // (if it's not determined yet).\n        else if (!this.country) {\n          this.determine_the_country();\n        }\n      } else {\n        // Some national prefixes are substrings of other national prefixes\n        // (for the same country), therefore try to extract national prefix each time\n        // because a longer national prefix might be available at some point in time.\n        var previous_national_prefix = this.national_prefix;\n        this.national_number = this.national_prefix + this.national_number; // Possibly extract a national prefix\n\n        this.extract_national_prefix();\n\n        if (this.national_prefix !== previous_national_prefix) {\n          // National number has changed\n          // (due to another national prefix been extracted)\n          // therefore national number has changed\n          // therefore reset all previous formatting data.\n          // (and leading digits matching state)\n          this.matching_formats = this.available_formats;\n          this.reset_format();\n        }\n      }\n\n      if (!this.should_format()) {\n        return this.format_as_non_formatted_number();\n      } // Check the available phone number formats\n      // based on the currently available leading digits.\n\n\n      this.match_formats_by_leading_digits(); // Format the phone number (given the next digits)\n\n      var formatted_national_phone_number = this.format_national_phone_number(input); // If the phone number could be formatted,\n      // then return it, possibly prepending with country phone code\n      // (for international phone numbers only)\n\n      if (formatted_national_phone_number) {\n        return this.full_phone_number(formatted_national_phone_number);\n      } // If the phone number couldn't be formatted,\n      // then just fall back to the raw phone number.\n\n\n      return this.parsed_input;\n    }\n  }, {\n    key: 'format_as_non_formatted_number',\n    value: function format_as_non_formatted_number() {\n      if (this.is_international() && this.country_phone_code) {\n        if (this.national_number) {\n          // For convenience, the public `.template` property\n          // contains the whole international number\n          // if the phone number being input is international:\n          // 'x' for the '+' sign, 'x'es for the country phone code,\n          // a spacebar and then the template for the national number digits.\n          this.template = DIGIT_PLACEHOLDER + repeat(DIGIT_PLACEHOLDER, this.country_phone_code.length) + ' ' + repeat(DIGIT_PLACEHOLDER, this.national_number.length);\n          return '+' + this.country_phone_code + ' ' + this.national_number;\n        }\n\n        return '+' + this.country_phone_code;\n      }\n\n      return this.parsed_input;\n    }\n  }, {\n    key: 'format_national_phone_number',\n    value: function format_national_phone_number(next_digits) {\n      // Format the next phone number digits\n      // using the previously chosen phone number format.\n      //\n      // This is done here because if `attempt_to_format_complete_phone_number`\n      // was placed before this call then the `template`\n      // wouldn't reflect the situation correctly (and would therefore be inconsistent)\n      //\n      var national_number_formatted_with_previous_format = void 0;\n\n      if (this.chosen_format) {\n        national_number_formatted_with_previous_format = this.format_next_national_number_digits(next_digits);\n      } // See if the input digits can be formatted properly already. If not,\n      // use the results from format_next_national_number_digits(), which does formatting\n      // based on the formatting pattern chosen.\n\n\n      var formatted_number = this.attempt_to_format_complete_phone_number(); // Just because a phone number doesn't have a suitable format\n      // that doesn't mean that the phone is invalid\n      // because phone number formats only format phone numbers,\n      // they don't validate them and some (rare) phone numbers\n      // are meant to stay non-formatted.\n\n      if (formatted_number) {\n        // if (this.country)\n        // {\n        // \tthis.valid = true\n        // }\n        return formatted_number;\n      } // For some phone number formats national prefix\n      // If the previously chosen phone number format\n      // didn't match the next (current) digit being input\n      // (leading digits pattern didn't match).\n\n\n      if (this.choose_another_format()) {\n        // And a more appropriate phone number format\n        // has been chosen for these `leading digits`,\n        // then format the national phone number (so far)\n        // using the newly selected phone number pattern.\n        // Will return `undefined` if it couldn't format\n        // the supplied national number\n        // using the selected phone number pattern.\n        return this.reformat_national_number();\n      } // If could format the next (current) digit\n      // using the previously chosen phone number format\n      // then return the formatted number so far.\n      // If no new phone number format could be chosen,\n      // and couldn't format the supplied national number\n      // using the selected phone number pattern,\n      // then it will return `undefined`.\n\n\n      return national_number_formatted_with_previous_format;\n    }\n  }, {\n    key: 'reset',\n    value: function reset() {\n      // Input stripped of non-phone-number characters.\n      // Can only contain a possible leading '+' sign and digits.\n      this.parsed_input = '';\n      this.current_output = ''; // This contains the national prefix that has been extracted. It contains only\n      // digits without formatting.\n\n      this.national_prefix = '';\n      this.national_number = '';\n      this.reset_countriness();\n      this.reset_format(); // this.valid = false\n\n      return this;\n    }\n  }, {\n    key: 'reset_country',\n    value: function reset_country() {\n      if (this.default_country && !this.is_international()) {\n        this.country = this.default_country;\n      } else {\n        this.country = undefined;\n      }\n    }\n  }, {\n    key: 'reset_countriness',\n    value: function reset_countriness() {\n      this.reset_country();\n\n      if (this.default_country && !this.is_international()) {\n        this.country_metadata = this.metadata.countries[this.default_country];\n        this.country_phone_code = get_phone_code(this.country_metadata);\n        this.initialize_phone_number_formats_for_this_country_phone_code();\n      } else {\n        this.country_metadata = undefined;\n        this.country_phone_code = undefined;\n        this.available_formats = [];\n        this.matching_formats = this.available_formats;\n      }\n    }\n  }, {\n    key: 'reset_format',\n    value: function reset_format() {\n      this.chosen_format = undefined;\n      this.template = undefined;\n      this.partially_populated_template = undefined;\n      this.last_match_position = -1;\n    } // Format each digit of national phone number (so far)\n    // using the newly selected phone number pattern.\n\n  }, {\n    key: 'reformat_national_number',\n    value: function reformat_national_number() {\n      // Format each digit of national phone number (so far)\n      // using the selected phone number pattern.\n      return this.format_next_national_number_digits(this.national_number);\n    }\n  }, {\n    key: 'initialize_phone_number_formats_for_this_country_phone_code',\n    value: function initialize_phone_number_formats_for_this_country_phone_code() {\n      // Get all \"eligible\" phone number formats for this country\n      this.available_formats = get_formats(this.country_metadata).filter(function (format) {\n        return ELIGIBLE_FORMAT_PATTERN.test(get_format_international_format(format));\n      });\n      this.matching_formats = this.available_formats;\n    }\n  }, {\n    key: 'match_formats_by_leading_digits',\n    value: function match_formats_by_leading_digits() {\n      var leading_digits = this.national_number; // \"leading digits\" pattern list starts with\n      // one of a maximum length of 3 digits,\n      // and then with each additional digit\n      // a more precise \"leading digits\" pattern is specified.\n\n      var index_of_leading_digits_pattern = leading_digits.length - MIN_LEADING_DIGITS_LENGTH;\n\n      if (index_of_leading_digits_pattern < 0) {\n        index_of_leading_digits_pattern = 0;\n      }\n\n      this.matching_formats = this.matching_formats.filter(function (format) {\n        var leading_digits_pattern_count = get_format_leading_digits_patterns(format).length; // Keep everything that isn't restricted by leading digits.\n\n        if (leading_digits_pattern_count === 0) {\n          return true;\n        }\n\n        var leading_digits_pattern_index = Math.min(index_of_leading_digits_pattern, leading_digits_pattern_count - 1);\n        var leading_digits_pattern = get_format_leading_digits_patterns(format)[leading_digits_pattern_index]; // Brackets are required for `^` to be applied to\n        // all or-ed (`|`) parts, not just the first one.\n\n        return new RegExp('^(' + leading_digits_pattern + ')').test(leading_digits);\n      }); // If there was a phone number format chosen\n      // and it no longer holds given the new leading digits then reset it.\n      // The test for this `if` condition is marked as:\n      // \"Reset a chosen format when it no longer holds given the new leading digits\".\n\n      if (this.chosen_format && this.matching_formats.indexOf(this.chosen_format) === -1) {\n        this.reset_format();\n      }\n    }\n  }, {\n    key: 'should_format',\n    value: function should_format() {\n      // Start matching any formats at all when the national number\n      // entered so far is at least 3 digits long,\n      // otherwise format matching would give false negatives\n      // like when the digits entered so far are `2`\n      // and the leading digits pattern is `21` â€“\n      // it's quite obvious in this case that the format could be the one\n      // but due to the absence of further digits it would give false negative.\n      //\n      // Google could have provided leading digits patterns starting\n      // with a single digit but they chose not to (for whatever reasons).\n      //\n      return this.national_number >= MIN_LEADING_DIGITS_LENGTH;\n    } // Check to see if there is an exact pattern match for these digits. If so, we\n    // should use this instead of any other formatting template whose\n    // leadingDigitsPattern also matches the input.\n\n  }, {\n    key: 'attempt_to_format_complete_phone_number',\n    value: function attempt_to_format_complete_phone_number() {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = _getIterator(this.matching_formats), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var format = _step.value;\n          var matcher = new RegExp('^(?:' + get_format_pattern(format) + ')$');\n\n          if (!matcher.test(this.national_number)) {\n            continue;\n          }\n\n          if (!this.validate_format(format)) {\n            continue;\n          } // To leave the formatter in a consistent state\n\n\n          this.reset_format();\n          this.chosen_format = format;\n          var formatted_number = format_national_number_using_format(this.national_number, format, this.is_international(), this.national_prefix.length > 0, this.country_metadata); // Set `this.template` and `this.partially_populated_template`.\n          //\n          // `else` case doesn't ever happen\n          // with the current metadata,\n          // but just in case.\n          //\n\n          /* istanbul ignore else */\n\n          if (this.create_formatting_template(format)) {\n            // Populate `this.partially_populated_template`\n            this.reformat_national_number();\n          } else {\n            // Prepend `+CountryCode` in case of an international phone number\n            var full_number = this.full_phone_number(formatted_number);\n            this.template = full_number.replace(/[\\d\\+]/g, DIGIT_PLACEHOLDER);\n            this.partially_populated_template = full_number;\n          }\n\n          return formatted_number;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    } // Prepends `+CountryCode` in case of an international phone number\n\n  }, {\n    key: 'full_phone_number',\n    value: function full_phone_number(formatted_national_number) {\n      if (this.is_international()) {\n        return '+' + this.country_phone_code + ' ' + formatted_national_number;\n      }\n\n      return formatted_national_number;\n    } // Extracts the country calling code from the beginning\n    // of the entered `national_number` (so far),\n    // and places the remaining input into the `national_number`.\n\n  }, {\n    key: 'extract_country_phone_code',\n    value: function extract_country_phone_code() {\n      if (!this.national_number) {\n        return;\n      }\n\n      var _parse_phone_number_a = parse_phone_number_and_country_phone_code(this.parsed_input, this.metadata),\n          country_phone_code = _parse_phone_number_a.country_phone_code,\n          number = _parse_phone_number_a.number;\n\n      if (!country_phone_code) {\n        return;\n      }\n\n      this.country_phone_code = country_phone_code;\n      this.national_number = number;\n      return this.country_metadata = get_metadata_by_country_phone_code(country_phone_code, this.metadata);\n    }\n  }, {\n    key: 'extract_national_prefix',\n    value: function extract_national_prefix() {\n      this.national_prefix = '';\n\n      if (!this.country_metadata) {\n        return;\n      }\n\n      var national_number = strip_national_prefix(this.national_number, this.country_metadata);\n\n      if (national_number !== this.national_number) {\n        this.national_prefix = this.national_number.slice(0, this.national_number.length - national_number.length);\n        this.national_number = national_number;\n      }\n\n      return this.national_prefix;\n    }\n  }, {\n    key: 'choose_another_format',\n    value: function choose_another_format() {\n      // When there are multiple available formats, the formatter uses the first\n      // format where a formatting template could be created.\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = _getIterator(this.matching_formats), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var format = _step2.value; // If this format is currently being used\n          // and is still possible, then stick to it.\n\n          if (this.chosen_format === format) {\n            return;\n          } // If this `format` is suitable for \"as you type\",\n          // then extract the template from this format\n          // and use it to format the phone number being input.\n\n\n          if (!this.validate_format(format)) {\n            continue;\n          }\n\n          if (!this.create_formatting_template(format)) {\n            continue;\n          }\n\n          this.chosen_format = format; // With a new formatting template, the matched position\n          // using the old template needs to be reset.\n\n          this.last_match_position = -1;\n          return true;\n        } // No format matches the phone number,\n        // therefore set `country` to `undefined`\n        // (or to the default country).\n\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      this.reset_country(); // No format matches the national phone number entered\n\n      this.reset_format();\n    }\n  }, {\n    key: 'validate_format',\n    value: function validate_format(format) {\n      // If national prefix is mandatory for this phone number format\n      // and the user didn't input the national prefix,\n      // then this phone number format isn't suitable.\n      if (!this.is_international() && !this.national_prefix && get_format_national_prefix_is_mandatory_when_formatting(format, this.country_metadata)) {\n        return;\n      }\n\n      return true;\n    }\n  }, {\n    key: 'create_formatting_template',\n    value: function create_formatting_template(format) {\n      // The formatter doesn't format numbers when numberPattern contains '|', e.g.\n      // (20|3)\\d{4}. In those cases we quickly return.\n      // (Though there's no such format in current metadata)\n\n      /* istanbul ignore if */\n      if (get_format_pattern(format).indexOf('|') >= 0) {\n        return;\n      } // Get formatting template for this phone number format\n\n\n      var template = this.get_template_for_phone_number_format_pattern(format); // If the national number entered is too long\n      // for any phone number format, then abort.\n\n      if (!template) {\n        return;\n      } // This one is for national number only\n\n\n      this.partially_populated_template = template; // For convenience, the public `.template` property\n      // contains the whole international number\n      // if the phone number being input is international:\n      // 'x' for the '+' sign, 'x'es for the country phone code,\n      // a spacebar and then the template for the formatted national number.\n\n      if (this.is_international()) {\n        this.template = DIGIT_PLACEHOLDER + repeat(DIGIT_PLACEHOLDER, this.country_phone_code.length) + ' ' + template;\n      } // For local numbers, replace national prefix\n      // with a digit placeholder.\n      else {\n        this.template = template.replace(/\\d/g, DIGIT_PLACEHOLDER);\n      } // This one is for the full phone number\n\n\n      return this.template;\n    } // Generates formatting template for a phone number format\n\n  }, {\n    key: 'get_template_for_phone_number_format_pattern',\n    value: function get_template_for_phone_number_format_pattern(format) {\n      var national_prefix_formatting_rule = get_format_national_prefix_formatting_rule(format, this.country_metadata); // A very smart trick by the guys at Google\n\n      var number_pattern = get_format_pattern(format) // Replace anything in the form of [..] with \\d\n      .replace(CHARACTER_CLASS_PATTERN, '\\\\d') // Replace any standalone digit (not the one in `{}`) with \\d\n      .replace(STANDALONE_DIGIT_PATTERN, '\\\\d'); // This match will always succeed,\n      // because the \"longest dummy phone number\"\n      // has enough length to accomodate any possible\n      // national phone number format pattern.\n\n      var dummy_phone_number_matching_format_pattern = LONGEST_DUMMY_PHONE_NUMBER.match(number_pattern)[0]; // If the national number entered is too long\n      // for any phone number format, then abort.\n\n      if (this.national_number.length > dummy_phone_number_matching_format_pattern.length) {\n        return;\n      } // Prepare the phone number format\n\n\n      var number_format = this.get_format_format(format, national_prefix_formatting_rule); // Get a formatting template which can be used to efficiently format\n      // a partial number where digits are added one by one.\n      // Below `strict_pattern` is used for the\n      // regular expression (with `^` and `$`).\n      // This wasn't originally in Google's `libphonenumber`\n      // and I guess they don't really need it\n      // because they're not using \"templates\" to format phone numbers\n      // but I added `strict_pattern` after encountering\n      // South Korean phone number formatting bug.\n      //\n      // Non-strict regular expression bug demonstration:\n      //\n      // this.national_number : `111111111` (9 digits)\n      //\n      // number_pattern : (\\d{2})(\\d{3,4})(\\d{4})\n      // number_format : `$1 $2 $3`\n      // dummy_phone_number_matching_format_pattern : `9999999999` (10 digits)\n      //\n      // '9999999999'.replace(new RegExp(/(\\d{2})(\\d{3,4})(\\d{4})/g), '$1 $2 $3') = \"99 9999 9999\"\n      //\n      // template : xx xxxx xxxx\n      //\n      // But the correct template in this case is `xx xxx xxxx`.\n      // The template was generated incorrectly because of the\n      // `{3,4}` variability in the `number_pattern`.\n      //\n      // The fix is, if `this.national_number` has already sufficient length\n      // to satisfy the `number_pattern` completely then `this.national_number` is used\n      // instead of `dummy_phone_number_matching_format_pattern`.\n\n      var strict_pattern = new RegExp('^' + number_pattern + '$');\n      var national_number_dummy_digits = this.national_number.replace(/\\d/g, DUMMY_DIGIT); // If `this.national_number` has already sufficient length\n      // to satisfy the `number_pattern` completely then use it\n      // instead of `dummy_phone_number_matching_format_pattern`.\n\n      if (strict_pattern.test(national_number_dummy_digits)) {\n        dummy_phone_number_matching_format_pattern = national_number_dummy_digits;\n      } // Generate formatting template for this phone number format\n\n\n      return dummy_phone_number_matching_format_pattern // Format the dummy phone number according to the format\n      .replace(new RegExp(number_pattern), number_format) // Replace each dummy digit with a DIGIT_PLACEHOLDER\n      .replace(DUMMY_DIGIT_MATCHER, DIGIT_PLACEHOLDER);\n    }\n  }, {\n    key: 'format_next_national_number_digits',\n    value: function format_next_national_number_digits(digits) {\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = _getIterator(digits), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var digit = _step3.value; // If there is room for more digits in current `template`,\n          // then set the next digit in the `template`,\n          // and return the formatted digits so far.\n          // If more digits are entered than the current format could handle\n\n          if (this.partially_populated_template.slice(this.last_match_position + 1).search(DIGIT_PLACEHOLDER_MATCHER) === -1) {\n            // Reset the current format,\n            // so that the new format will be chosen\n            // in a subsequent `this.choose_another_format()` call\n            // later in code.\n            this.chosen_format = undefined;\n            this.template = undefined;\n            this.partially_populated_template = undefined;\n            return;\n          }\n\n          this.last_match_position = this.partially_populated_template.search(DIGIT_PLACEHOLDER_MATCHER);\n          this.partially_populated_template = this.partially_populated_template.replace(DIGIT_PLACEHOLDER_MATCHER, digit);\n        } // Return the formatted phone number so far\n\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      return close_dangling_braces(this.partially_populated_template, this.last_match_position + 1).replace(DIGIT_PLACEHOLDER_MATCHER_GLOBAL, ' ');\n    }\n  }, {\n    key: 'is_international',\n    value: function is_international() {\n      return this.parsed_input && this.parsed_input[0] === '+';\n    }\n  }, {\n    key: 'get_format_format',\n    value: function get_format_format(format, national_prefix_formatting_rule) {\n      var number_format = this.is_international() ? get_format_international_format(format) : _get_format_format(format); // If national prefix formatting rule is set\n      // for this phone number format\n\n      if (national_prefix_formatting_rule) {\n        // If the user did input the national prefix\n        // (or if the national prefix formatting rule does not require national prefix)\n        // then maybe make it part of the phone number template\n        if (this.national_prefix || !get_format_uses_national_prefix(national_prefix_formatting_rule)) {\n          // Make the national prefix part of the phone number template\n          number_format = number_format.replace(FIRST_GROUP_PATTERN, national_prefix_formatting_rule);\n        }\n      }\n\n      if (this.is_international()) {\n        return local_to_international_style(number_format);\n      }\n\n      return number_format;\n    } // Determines the country of the phone number\n    // entered so far based on the country phone code\n    // and the national phone number.\n\n  }, {\n    key: 'determine_the_country',\n    value: function determine_the_country() {\n      this.country = find_country_code(this.country_phone_code, this.national_number, this.metadata);\n    }\n  }]);\n\n  return as_you_type;\n}();\n\nexport default as_you_type;\nexport function close_dangling_braces(template, cut_before) {\n  var retained_template = template.slice(0, cut_before);\n  var opening_braces = count_occurences('(', retained_template);\n  var closing_braces = count_occurences(')', retained_template);\n  var dangling_braces = opening_braces - closing_braces;\n\n  while (dangling_braces > 0 && cut_before < template.length) {\n    if (template[cut_before] === ')') {\n      dangling_braces--;\n    }\n\n    cut_before++;\n  }\n\n  return template.slice(0, cut_before);\n} // Counts all occurences of a symbol in a string\n\nexport function count_occurences(symbol, string) {\n  var count = 0;\n  var _iteratorNormalCompletion4 = true;\n  var _didIteratorError4 = false;\n  var _iteratorError4 = undefined;\n\n  try {\n    for (var _iterator4 = _getIterator(string), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n      var character = _step4.value;\n\n      if (character === symbol) {\n        count++;\n      }\n    }\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion4 && _iterator4.return) {\n        _iterator4.return();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n\n  return count;\n} // Repeats a string (or a symbol) N times.\n// http://stackoverflow.com/questions/202605/repeat-string-javascript\n\nexport function repeat(string, times) {\n  if (times < 1) {\n    return '';\n  }\n\n  var result = '';\n\n  while (times > 1) {\n    if (times & 1) {\n      result += string;\n    }\n\n    times >>= 1;\n    string += string;\n  }\n\n  return result + string;\n}","map":{"version":3,"names":["_getIterator","_classCallCheck","_createClass","get_phone_code","get_national_prefix","get_national_prefix_for_parsing","get_formats","get_format_pattern","get_format_format","_get_format_format","get_format_international_format","get_format_national_prefix_formatting_rule","get_format_national_prefix_is_mandatory_when_formatting","get_format_leading_digits_patterns","get_format_uses_national_prefix","get_metadata_by_country_phone_code","VALID_PUNCTUATION","PLUS_CHARS","VALID_DIGITS","extract_formatted_phone_number","parse_phone_number","parse_phone_number_and_country_phone_code","find_country_code","strip_national_prefix","FIRST_GROUP_PATTERN","format_national_number_using_format","local_to_international_style","matches_entirely","DUMMY_DIGIT","DUMMY_DIGIT_MATCHER","RegExp","LONGEST_NATIONAL_PHONE_NUMBER_LENGTH","LONGEST_DUMMY_PHONE_NUMBER","repeat","DIGIT_PLACEHOLDER","DIGIT_PLACEHOLDER_MATCHER","DIGIT_PLACEHOLDER_MATCHER_GLOBAL","CHARACTER_CLASS_PATTERN","STANDALONE_DIGIT_PATTERN","ELIGIBLE_FORMAT_PATTERN","MIN_LEADING_DIGITS_LENGTH","VALID_INCOMPLETE_PHONE_NUMBER","VALID_INCOMPLETE_PHONE_NUMBER_PATTERN","as_you_type","country_code","metadata","countries","Error","default_country","reset","key","value","input","text","extracted_number","indexOf","current_output","process_input","parsed_input","reset_countriness","slice","national_number","is_international","country_phone_code","extract_country_phone_code","initialize_phone_number_formats_for_this_country_phone_code","reset_format","determine_the_country","country","previous_national_prefix","national_prefix","extract_national_prefix","matching_formats","available_formats","should_format","format_as_non_formatted_number","match_formats_by_leading_digits","formatted_national_phone_number","format_national_phone_number","full_phone_number","template","length","next_digits","national_number_formatted_with_previous_format","chosen_format","format_next_national_number_digits","formatted_number","attempt_to_format_complete_phone_number","choose_another_format","reformat_national_number","reset_country","undefined","country_metadata","partially_populated_template","last_match_position","filter","format","test","leading_digits","index_of_leading_digits_pattern","leading_digits_pattern_count","leading_digits_pattern_index","Math","min","leading_digits_pattern","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","_step","next","done","matcher","validate_format","create_formatting_template","full_number","replace","err","return","formatted_national_number","_parse_phone_number_a","number","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","get_template_for_phone_number_format_pattern","national_prefix_formatting_rule","number_pattern","dummy_phone_number_matching_format_pattern","match","number_format","strict_pattern","national_number_dummy_digits","digits","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_iterator3","_step3","digit","search","close_dangling_braces","cut_before","retained_template","opening_braces","count_occurences","closing_braces","dangling_braces","symbol","string","count","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_iterator4","_step4","character","times","result"],"sources":["/usr/src/app/node_modules/libphonenumber-js/es6/AsYouType.js"],"sourcesContent":["import _getIterator from 'babel-runtime/core-js/get-iterator';\nimport _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport _createClass from 'babel-runtime/helpers/createClass';\n// This is an enhanced port of Google Android `libphonenumber`'s\n// `asyoutypeformatter.js` of 17th November, 2016.\n//\n// https://github.com/googlei18n/libphonenumber/blob/8d21a365061de2ba0675c878a710a7b24f74d2ae/javascript/i18n/phonenumbers/asyoutypeformatter.js\n\nimport { get_phone_code, get_national_prefix, get_national_prefix_for_parsing, get_formats, get_format_pattern, get_format_format as _get_format_format, get_format_international_format, get_format_national_prefix_formatting_rule, get_format_national_prefix_is_mandatory_when_formatting, get_format_leading_digits_patterns, get_format_uses_national_prefix, get_metadata_by_country_phone_code } from './metadata';\n\nimport { VALID_PUNCTUATION, PLUS_CHARS, VALID_DIGITS, extract_formatted_phone_number, parse_phone_number, parse_phone_number_and_country_phone_code, find_country_code, strip_national_prefix } from './parse';\n\nimport { FIRST_GROUP_PATTERN, format_national_number_using_format, local_to_international_style } from './format';\n\nimport { matches_entirely } from './common';\n\n// Used in phone number format template creation.\n// Could be any digit, I guess.\nvar DUMMY_DIGIT = '9';\nvar DUMMY_DIGIT_MATCHER = new RegExp(DUMMY_DIGIT, 'g');\n// I don't know why is it exactly `15`\nvar LONGEST_NATIONAL_PHONE_NUMBER_LENGTH = 15;\n// Create a phone number consisting only of the digit 9 that matches the\n// `number_pattern` by applying the pattern to the \"longest phone number\" string.\nvar LONGEST_DUMMY_PHONE_NUMBER = repeat(DUMMY_DIGIT, LONGEST_NATIONAL_PHONE_NUMBER_LENGTH);\n\n// The digits that have not been entered yet will be represented by a \\u2008,\n// the punctuation space.\nexport var DIGIT_PLACEHOLDER = 'x'; // '\\u2008' (punctuation space)\nvar DIGIT_PLACEHOLDER_MATCHER = new RegExp(DIGIT_PLACEHOLDER);\nvar DIGIT_PLACEHOLDER_MATCHER_GLOBAL = new RegExp(DIGIT_PLACEHOLDER, 'g');\n\n// A pattern that is used to match character classes in regular expressions.\n// An example of a character class is \"[1-4]\".\nvar CHARACTER_CLASS_PATTERN = /\\[([^\\[\\]])*\\]/g;\n\n// Any digit in a regular expression that actually denotes a digit. For\n// example, in the regular expression \"80[0-2]\\d{6,10}\", the first 2 digits\n// (8 and 0) are standalone digits, but the rest are not.\n// Two look-aheads are needed because the number following \\\\d could be a\n// two-digit number, since the phone number can be as long as 15 digits.\nvar STANDALONE_DIGIT_PATTERN = /\\d(?=[^,}][^,}])/g;\n\n// A pattern that is used to determine if a `format` is eligible\n// to be used by the \"as you type formatter\".\n// It is eligible when the `format` contains groups of the dollar sign\n// followed by a single digit, separated by valid phone number punctuation.\n// This prevents invalid punctuation (such as the star sign in Israeli star numbers)\n// getting into the output of the \"as you type formatter\".\nvar ELIGIBLE_FORMAT_PATTERN = new RegExp('^' + '[' + VALID_PUNCTUATION + ']*' + '(\\\\$\\\\d[' + VALID_PUNCTUATION + ']*)+' + '$');\n\n// This is the minimum length of the leading digits of a phone number\n// to guarantee the first \"leading digits pattern\" for a phone number format\n// to be preemptive.\nvar MIN_LEADING_DIGITS_LENGTH = 3;\n\nvar VALID_INCOMPLETE_PHONE_NUMBER = '[' + PLUS_CHARS + ']{0,1}' + '[' + VALID_PUNCTUATION + VALID_DIGITS + ']*';\n\nvar VALID_INCOMPLETE_PHONE_NUMBER_PATTERN = new RegExp('^' + VALID_INCOMPLETE_PHONE_NUMBER + '$', 'i');\n\nvar as_you_type = function () {\n\tfunction as_you_type(country_code, metadata) {\n\t\t_classCallCheck(this, as_you_type);\n\n\t\t// Metadata is required.\n\t\tif (!metadata || !metadata.countries) {\n\t\t\tthrow new Error('Metadata is required');\n\t\t}\n\n\t\tif (country_code && metadata.countries[country_code]) {\n\t\t\tthis.default_country = country_code;\n\t\t}\n\n\t\tthis.metadata = metadata;\n\n\t\tthis.reset();\n\t}\n\n\t_createClass(as_you_type, [{\n\t\tkey: 'input',\n\t\tvalue: function input(text) {\n\t\t\t// Parse input\n\n\t\t\tvar extracted_number = extract_formatted_phone_number(text);\n\n\t\t\t// Special case for a lone '+' sign\n\t\t\t// since it's not considered a possible phone number.\n\t\t\tif (!extracted_number) {\n\t\t\t\tif (text && text.indexOf('+') >= 0) {\n\t\t\t\t\textracted_number = '+';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Validate possible first part of a phone number\n\t\t\tif (!matches_entirely(extracted_number, VALID_INCOMPLETE_PHONE_NUMBER_PATTERN)) {\n\t\t\t\treturn this.current_output;\n\t\t\t}\n\n\t\t\treturn this.process_input(parse_phone_number(extracted_number));\n\t\t}\n\t}, {\n\t\tkey: 'process_input',\n\t\tvalue: function process_input(input) {\n\t\t\t// If an out of position '+' sign detected\n\t\t\t// (or a second '+' sign),\n\t\t\t// then just drop it from the input.\n\t\t\tif (input[0] === '+') {\n\t\t\t\tif (!this.parsed_input) {\n\t\t\t\t\tthis.parsed_input += '+';\n\n\t\t\t\t\t// If a default country was set\n\t\t\t\t\t// then reset it because an explicitly international\n\t\t\t\t\t// phone number is being entered\n\t\t\t\t\tthis.reset_countriness();\n\t\t\t\t}\n\n\t\t\t\tinput = input.slice(1);\n\t\t\t}\n\n\t\t\t// Raw phone number\n\t\t\tthis.parsed_input += input;\n\n\t\t\t// // Reset phone number validation state\n\t\t\t// this.valid = false\n\n\t\t\t// Add digits to the national number\n\t\t\tthis.national_number += input;\n\n\t\t\t// Try to format the parsed input\n\n\t\t\tif (this.is_international()) {\n\t\t\t\tif (!this.country_phone_code) {\n\t\t\t\t\t// If one looks at country phone codes\n\t\t\t\t\t// then he can notice that no one country phone code\n\t\t\t\t\t// is ever a (leftmost) substring of another country phone code.\n\t\t\t\t\t// So if a valid country code is extracted so far\n\t\t\t\t\t// then it means that this is the country code.\n\n\t\t\t\t\t// If no country phone code could be extracted so far,\n\t\t\t\t\t// then just return the raw phone number,\n\t\t\t\t\t// because it has no way of knowing\n\t\t\t\t\t// how to format the phone number so far.\n\t\t\t\t\tif (!this.extract_country_phone_code()) {\n\t\t\t\t\t\t// Return raw phone number\n\t\t\t\t\t\treturn this.parsed_input;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Initialize country-specific data\n\t\t\t\t\tthis.initialize_phone_number_formats_for_this_country_phone_code();\n\t\t\t\t\tthis.reset_format();\n\t\t\t\t\tthis.determine_the_country();\n\t\t\t\t}\n\t\t\t\t// `this.country` could be `undefined`,\n\t\t\t\t// for instance, when there is ambiguity\n\t\t\t\t// in a form of several different countries\n\t\t\t\t// each corresponding to the same country phone code\n\t\t\t\t// (e.g. NANPA: USA, Canada, etc),\n\t\t\t\t// and there's not enough digits entered\n\t\t\t\t// to reliably determine the country\n\t\t\t\t// the phone number belongs to.\n\t\t\t\t// Therefore, in cases of such ambiguity,\n\t\t\t\t// each time something is input,\n\t\t\t\t// try to determine the country\n\t\t\t\t// (if it's not determined yet).\n\t\t\t\telse if (!this.country) {\n\t\t\t\t\t\tthis.determine_the_country();\n\t\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Some national prefixes are substrings of other national prefixes\n\t\t\t\t// (for the same country), therefore try to extract national prefix each time\n\t\t\t\t// because a longer national prefix might be available at some point in time.\n\n\t\t\t\tvar previous_national_prefix = this.national_prefix;\n\t\t\t\tthis.national_number = this.national_prefix + this.national_number;\n\n\t\t\t\t// Possibly extract a national prefix\n\t\t\t\tthis.extract_national_prefix();\n\n\t\t\t\tif (this.national_prefix !== previous_national_prefix) {\n\t\t\t\t\t// National number has changed\n\t\t\t\t\t// (due to another national prefix been extracted)\n\t\t\t\t\t// therefore national number has changed\n\t\t\t\t\t// therefore reset all previous formatting data.\n\t\t\t\t\t// (and leading digits matching state)\n\t\t\t\t\tthis.matching_formats = this.available_formats;\n\t\t\t\t\tthis.reset_format();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!this.should_format()) {\n\t\t\t\treturn this.format_as_non_formatted_number();\n\t\t\t}\n\n\t\t\t// Check the available phone number formats\n\t\t\t// based on the currently available leading digits.\n\t\t\tthis.match_formats_by_leading_digits();\n\n\t\t\t// Format the phone number (given the next digits)\n\t\t\tvar formatted_national_phone_number = this.format_national_phone_number(input);\n\n\t\t\t// If the phone number could be formatted,\n\t\t\t// then return it, possibly prepending with country phone code\n\t\t\t// (for international phone numbers only)\n\t\t\tif (formatted_national_phone_number) {\n\t\t\t\treturn this.full_phone_number(formatted_national_phone_number);\n\t\t\t}\n\n\t\t\t// If the phone number couldn't be formatted,\n\t\t\t// then just fall back to the raw phone number.\n\t\t\treturn this.parsed_input;\n\t\t}\n\t}, {\n\t\tkey: 'format_as_non_formatted_number',\n\t\tvalue: function format_as_non_formatted_number() {\n\t\t\tif (this.is_international() && this.country_phone_code) {\n\t\t\t\tif (this.national_number) {\n\t\t\t\t\t// For convenience, the public `.template` property\n\t\t\t\t\t// contains the whole international number\n\t\t\t\t\t// if the phone number being input is international:\n\t\t\t\t\t// 'x' for the '+' sign, 'x'es for the country phone code,\n\t\t\t\t\t// a spacebar and then the template for the national number digits.\n\t\t\t\t\tthis.template = DIGIT_PLACEHOLDER + repeat(DIGIT_PLACEHOLDER, this.country_phone_code.length) + ' ' + repeat(DIGIT_PLACEHOLDER, this.national_number.length);\n\n\t\t\t\t\treturn '+' + this.country_phone_code + ' ' + this.national_number;\n\t\t\t\t}\n\n\t\t\t\treturn '+' + this.country_phone_code;\n\t\t\t}\n\n\t\t\treturn this.parsed_input;\n\t\t}\n\t}, {\n\t\tkey: 'format_national_phone_number',\n\t\tvalue: function format_national_phone_number(next_digits) {\n\t\t\t// Format the next phone number digits\n\t\t\t// using the previously chosen phone number format.\n\t\t\t//\n\t\t\t// This is done here because if `attempt_to_format_complete_phone_number`\n\t\t\t// was placed before this call then the `template`\n\t\t\t// wouldn't reflect the situation correctly (and would therefore be inconsistent)\n\t\t\t//\n\t\t\tvar national_number_formatted_with_previous_format = void 0;\n\t\t\tif (this.chosen_format) {\n\t\t\t\tnational_number_formatted_with_previous_format = this.format_next_national_number_digits(next_digits);\n\t\t\t}\n\n\t\t\t// See if the input digits can be formatted properly already. If not,\n\t\t\t// use the results from format_next_national_number_digits(), which does formatting\n\t\t\t// based on the formatting pattern chosen.\n\n\t\t\tvar formatted_number = this.attempt_to_format_complete_phone_number();\n\n\t\t\t// Just because a phone number doesn't have a suitable format\n\t\t\t// that doesn't mean that the phone is invalid\n\t\t\t// because phone number formats only format phone numbers,\n\t\t\t// they don't validate them and some (rare) phone numbers\n\t\t\t// are meant to stay non-formatted.\n\t\t\tif (formatted_number) {\n\t\t\t\t// if (this.country)\n\t\t\t\t// {\n\t\t\t\t// \tthis.valid = true\n\t\t\t\t// }\n\n\t\t\t\treturn formatted_number;\n\t\t\t}\n\n\t\t\t// For some phone number formats national prefix\n\n\t\t\t// If the previously chosen phone number format\n\t\t\t// didn't match the next (current) digit being input\n\t\t\t// (leading digits pattern didn't match).\n\t\t\tif (this.choose_another_format()) {\n\t\t\t\t// And a more appropriate phone number format\n\t\t\t\t// has been chosen for these `leading digits`,\n\t\t\t\t// then format the national phone number (so far)\n\t\t\t\t// using the newly selected phone number pattern.\n\n\t\t\t\t// Will return `undefined` if it couldn't format\n\t\t\t\t// the supplied national number\n\t\t\t\t// using the selected phone number pattern.\n\n\t\t\t\treturn this.reformat_national_number();\n\t\t\t}\n\n\t\t\t// If could format the next (current) digit\n\t\t\t// using the previously chosen phone number format\n\t\t\t// then return the formatted number so far.\n\n\t\t\t// If no new phone number format could be chosen,\n\t\t\t// and couldn't format the supplied national number\n\t\t\t// using the selected phone number pattern,\n\t\t\t// then it will return `undefined`.\n\n\t\t\treturn national_number_formatted_with_previous_format;\n\t\t}\n\t}, {\n\t\tkey: 'reset',\n\t\tvalue: function reset() {\n\t\t\t// Input stripped of non-phone-number characters.\n\t\t\t// Can only contain a possible leading '+' sign and digits.\n\t\t\tthis.parsed_input = '';\n\n\t\t\tthis.current_output = '';\n\n\t\t\t// This contains the national prefix that has been extracted. It contains only\n\t\t\t// digits without formatting.\n\t\t\tthis.national_prefix = '';\n\n\t\t\tthis.national_number = '';\n\n\t\t\tthis.reset_countriness();\n\n\t\t\tthis.reset_format();\n\n\t\t\t// this.valid = false\n\n\t\t\treturn this;\n\t\t}\n\t}, {\n\t\tkey: 'reset_country',\n\t\tvalue: function reset_country() {\n\t\t\tif (this.default_country && !this.is_international()) {\n\t\t\t\tthis.country = this.default_country;\n\t\t\t} else {\n\t\t\t\tthis.country = undefined;\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'reset_countriness',\n\t\tvalue: function reset_countriness() {\n\t\t\tthis.reset_country();\n\n\t\t\tif (this.default_country && !this.is_international()) {\n\t\t\t\tthis.country_metadata = this.metadata.countries[this.default_country];\n\t\t\t\tthis.country_phone_code = get_phone_code(this.country_metadata);\n\n\t\t\t\tthis.initialize_phone_number_formats_for_this_country_phone_code();\n\t\t\t} else {\n\t\t\t\tthis.country_metadata = undefined;\n\t\t\t\tthis.country_phone_code = undefined;\n\n\t\t\t\tthis.available_formats = [];\n\t\t\t\tthis.matching_formats = this.available_formats;\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'reset_format',\n\t\tvalue: function reset_format() {\n\t\t\tthis.chosen_format = undefined;\n\t\t\tthis.template = undefined;\n\t\t\tthis.partially_populated_template = undefined;\n\t\t\tthis.last_match_position = -1;\n\t\t}\n\n\t\t// Format each digit of national phone number (so far)\n\t\t// using the newly selected phone number pattern.\n\n\t}, {\n\t\tkey: 'reformat_national_number',\n\t\tvalue: function reformat_national_number() {\n\t\t\t// Format each digit of national phone number (so far)\n\t\t\t// using the selected phone number pattern.\n\t\t\treturn this.format_next_national_number_digits(this.national_number);\n\t\t}\n\t}, {\n\t\tkey: 'initialize_phone_number_formats_for_this_country_phone_code',\n\t\tvalue: function initialize_phone_number_formats_for_this_country_phone_code() {\n\t\t\t// Get all \"eligible\" phone number formats for this country\n\t\t\tthis.available_formats = get_formats(this.country_metadata).filter(function (format) {\n\t\t\t\treturn ELIGIBLE_FORMAT_PATTERN.test(get_format_international_format(format));\n\t\t\t});\n\n\t\t\tthis.matching_formats = this.available_formats;\n\t\t}\n\t}, {\n\t\tkey: 'match_formats_by_leading_digits',\n\t\tvalue: function match_formats_by_leading_digits() {\n\t\t\tvar leading_digits = this.national_number;\n\n\t\t\t// \"leading digits\" pattern list starts with\n\t\t\t// one of a maximum length of 3 digits,\n\t\t\t// and then with each additional digit\n\t\t\t// a more precise \"leading digits\" pattern is specified.\n\n\t\t\tvar index_of_leading_digits_pattern = leading_digits.length - MIN_LEADING_DIGITS_LENGTH;\n\n\t\t\tif (index_of_leading_digits_pattern < 0) {\n\t\t\t\tindex_of_leading_digits_pattern = 0;\n\t\t\t}\n\n\t\t\tthis.matching_formats = this.matching_formats.filter(function (format) {\n\t\t\t\tvar leading_digits_pattern_count = get_format_leading_digits_patterns(format).length;\n\n\t\t\t\t// Keep everything that isn't restricted by leading digits.\n\t\t\t\tif (leading_digits_pattern_count === 0) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tvar leading_digits_pattern_index = Math.min(index_of_leading_digits_pattern, leading_digits_pattern_count - 1);\n\t\t\t\tvar leading_digits_pattern = get_format_leading_digits_patterns(format)[leading_digits_pattern_index];\n\n\t\t\t\t// Brackets are required for `^` to be applied to\n\t\t\t\t// all or-ed (`|`) parts, not just the first one.\n\t\t\t\treturn new RegExp('^(' + leading_digits_pattern + ')').test(leading_digits);\n\t\t\t});\n\n\t\t\t// If there was a phone number format chosen\n\t\t\t// and it no longer holds given the new leading digits then reset it.\n\t\t\t// The test for this `if` condition is marked as:\n\t\t\t// \"Reset a chosen format when it no longer holds given the new leading digits\".\n\t\t\tif (this.chosen_format && this.matching_formats.indexOf(this.chosen_format) === -1) {\n\t\t\t\tthis.reset_format();\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'should_format',\n\t\tvalue: function should_format() {\n\t\t\t// Start matching any formats at all when the national number\n\t\t\t// entered so far is at least 3 digits long,\n\t\t\t// otherwise format matching would give false negatives\n\t\t\t// like when the digits entered so far are `2`\n\t\t\t// and the leading digits pattern is `21` â€“\n\t\t\t// it's quite obvious in this case that the format could be the one\n\t\t\t// but due to the absence of further digits it would give false negative.\n\t\t\t//\n\t\t\t// Google could have provided leading digits patterns starting\n\t\t\t// with a single digit but they chose not to (for whatever reasons).\n\t\t\t//\n\t\t\treturn this.national_number >= MIN_LEADING_DIGITS_LENGTH;\n\t\t}\n\n\t\t// Check to see if there is an exact pattern match for these digits. If so, we\n\t\t// should use this instead of any other formatting template whose\n\t\t// leadingDigitsPattern also matches the input.\n\n\t}, {\n\t\tkey: 'attempt_to_format_complete_phone_number',\n\t\tvalue: function attempt_to_format_complete_phone_number() {\n\t\t\tvar _iteratorNormalCompletion = true;\n\t\t\tvar _didIteratorError = false;\n\t\t\tvar _iteratorError = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator = _getIterator(this.matching_formats), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\t\t\tvar format = _step.value;\n\n\t\t\t\t\tvar matcher = new RegExp('^(?:' + get_format_pattern(format) + ')$');\n\n\t\t\t\t\tif (!matcher.test(this.national_number)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!this.validate_format(format)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// To leave the formatter in a consistent state\n\t\t\t\t\tthis.reset_format();\n\t\t\t\t\tthis.chosen_format = format;\n\n\t\t\t\t\tvar formatted_number = format_national_number_using_format(this.national_number, format, this.is_international(), this.national_prefix.length > 0, this.country_metadata);\n\n\t\t\t\t\t// Set `this.template` and `this.partially_populated_template`.\n\t\t\t\t\t//\n\t\t\t\t\t// `else` case doesn't ever happen\n\t\t\t\t\t// with the current metadata,\n\t\t\t\t\t// but just in case.\n\t\t\t\t\t//\n\t\t\t\t\t/* istanbul ignore else */\n\t\t\t\t\tif (this.create_formatting_template(format)) {\n\t\t\t\t\t\t// Populate `this.partially_populated_template`\n\t\t\t\t\t\tthis.reformat_national_number();\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Prepend `+CountryCode` in case of an international phone number\n\t\t\t\t\t\tvar full_number = this.full_phone_number(formatted_number);\n\t\t\t\t\t\tthis.template = full_number.replace(/[\\d\\+]/g, DIGIT_PLACEHOLDER);\n\t\t\t\t\t\tthis.partially_populated_template = full_number;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn formatted_number;\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError = true;\n\t\t\t\t_iteratorError = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t\t\t_iterator.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError) {\n\t\t\t\t\t\tthrow _iteratorError;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Prepends `+CountryCode` in case of an international phone number\n\n\t}, {\n\t\tkey: 'full_phone_number',\n\t\tvalue: function full_phone_number(formatted_national_number) {\n\t\t\tif (this.is_international()) {\n\t\t\t\treturn '+' + this.country_phone_code + ' ' + formatted_national_number;\n\t\t\t}\n\n\t\t\treturn formatted_national_number;\n\t\t}\n\n\t\t// Extracts the country calling code from the beginning\n\t\t// of the entered `national_number` (so far),\n\t\t// and places the remaining input into the `national_number`.\n\n\t}, {\n\t\tkey: 'extract_country_phone_code',\n\t\tvalue: function extract_country_phone_code() {\n\t\t\tif (!this.national_number) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar _parse_phone_number_a = parse_phone_number_and_country_phone_code(this.parsed_input, this.metadata),\n\t\t\t    country_phone_code = _parse_phone_number_a.country_phone_code,\n\t\t\t    number = _parse_phone_number_a.number;\n\n\t\t\tif (!country_phone_code) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.country_phone_code = country_phone_code;\n\t\t\tthis.national_number = number;\n\n\t\t\treturn this.country_metadata = get_metadata_by_country_phone_code(country_phone_code, this.metadata);\n\t\t}\n\t}, {\n\t\tkey: 'extract_national_prefix',\n\t\tvalue: function extract_national_prefix() {\n\t\t\tthis.national_prefix = '';\n\n\t\t\tif (!this.country_metadata) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar national_number = strip_national_prefix(this.national_number, this.country_metadata);\n\n\t\t\tif (national_number !== this.national_number) {\n\t\t\t\tthis.national_prefix = this.national_number.slice(0, this.national_number.length - national_number.length);\n\t\t\t\tthis.national_number = national_number;\n\t\t\t}\n\n\t\t\treturn this.national_prefix;\n\t\t}\n\t}, {\n\t\tkey: 'choose_another_format',\n\t\tvalue: function choose_another_format() {\n\t\t\t// When there are multiple available formats, the formatter uses the first\n\t\t\t// format where a formatting template could be created.\n\t\t\tvar _iteratorNormalCompletion2 = true;\n\t\t\tvar _didIteratorError2 = false;\n\t\t\tvar _iteratorError2 = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator2 = _getIterator(this.matching_formats), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t\t\t\t\tvar format = _step2.value;\n\n\t\t\t\t\t// If this format is currently being used\n\t\t\t\t\t// and is still possible, then stick to it.\n\t\t\t\t\tif (this.chosen_format === format) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If this `format` is suitable for \"as you type\",\n\t\t\t\t\t// then extract the template from this format\n\t\t\t\t\t// and use it to format the phone number being input.\n\n\t\t\t\t\tif (!this.validate_format(format)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!this.create_formatting_template(format)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.chosen_format = format;\n\n\t\t\t\t\t// With a new formatting template, the matched position\n\t\t\t\t\t// using the old template needs to be reset.\n\t\t\t\t\tthis.last_match_position = -1;\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t// No format matches the phone number,\n\t\t\t\t// therefore set `country` to `undefined`\n\t\t\t\t// (or to the default country).\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError2 = true;\n\t\t\t\t_iteratorError2 = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t\t\t\t\t\t_iterator2.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError2) {\n\t\t\t\t\t\tthrow _iteratorError2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.reset_country();\n\n\t\t\t// No format matches the national phone number entered\n\t\t\tthis.reset_format();\n\t\t}\n\t}, {\n\t\tkey: 'validate_format',\n\t\tvalue: function validate_format(format) {\n\t\t\t// If national prefix is mandatory for this phone number format\n\t\t\t// and the user didn't input the national prefix,\n\t\t\t// then this phone number format isn't suitable.\n\t\t\tif (!this.is_international() && !this.national_prefix && get_format_national_prefix_is_mandatory_when_formatting(format, this.country_metadata)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t}, {\n\t\tkey: 'create_formatting_template',\n\t\tvalue: function create_formatting_template(format) {\n\t\t\t// The formatter doesn't format numbers when numberPattern contains '|', e.g.\n\t\t\t// (20|3)\\d{4}. In those cases we quickly return.\n\t\t\t// (Though there's no such format in current metadata)\n\t\t\t/* istanbul ignore if */\n\t\t\tif (get_format_pattern(format).indexOf('|') >= 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Get formatting template for this phone number format\n\t\t\tvar template = this.get_template_for_phone_number_format_pattern(format);\n\n\t\t\t// If the national number entered is too long\n\t\t\t// for any phone number format, then abort.\n\t\t\tif (!template) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// This one is for national number only\n\t\t\tthis.partially_populated_template = template;\n\n\t\t\t// For convenience, the public `.template` property\n\t\t\t// contains the whole international number\n\t\t\t// if the phone number being input is international:\n\t\t\t// 'x' for the '+' sign, 'x'es for the country phone code,\n\t\t\t// a spacebar and then the template for the formatted national number.\n\t\t\tif (this.is_international()) {\n\t\t\t\tthis.template = DIGIT_PLACEHOLDER + repeat(DIGIT_PLACEHOLDER, this.country_phone_code.length) + ' ' + template;\n\t\t\t}\n\t\t\t// For local numbers, replace national prefix\n\t\t\t// with a digit placeholder.\n\t\t\telse {\n\t\t\t\t\tthis.template = template.replace(/\\d/g, DIGIT_PLACEHOLDER);\n\t\t\t\t}\n\n\t\t\t// This one is for the full phone number\n\t\t\treturn this.template;\n\t\t}\n\n\t\t// Generates formatting template for a phone number format\n\n\t}, {\n\t\tkey: 'get_template_for_phone_number_format_pattern',\n\t\tvalue: function get_template_for_phone_number_format_pattern(format) {\n\t\t\tvar national_prefix_formatting_rule = get_format_national_prefix_formatting_rule(format, this.country_metadata);\n\n\t\t\t// A very smart trick by the guys at Google\n\t\t\tvar number_pattern = get_format_pattern(format)\n\t\t\t// Replace anything in the form of [..] with \\d\n\t\t\t.replace(CHARACTER_CLASS_PATTERN, '\\\\d')\n\t\t\t// Replace any standalone digit (not the one in `{}`) with \\d\n\t\t\t.replace(STANDALONE_DIGIT_PATTERN, '\\\\d');\n\n\t\t\t// This match will always succeed,\n\t\t\t// because the \"longest dummy phone number\"\n\t\t\t// has enough length to accomodate any possible\n\t\t\t// national phone number format pattern.\n\t\t\tvar dummy_phone_number_matching_format_pattern = LONGEST_DUMMY_PHONE_NUMBER.match(number_pattern)[0];\n\n\t\t\t// If the national number entered is too long\n\t\t\t// for any phone number format, then abort.\n\t\t\tif (this.national_number.length > dummy_phone_number_matching_format_pattern.length) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Prepare the phone number format\n\t\t\tvar number_format = this.get_format_format(format, national_prefix_formatting_rule);\n\n\t\t\t// Get a formatting template which can be used to efficiently format\n\t\t\t// a partial number where digits are added one by one.\n\n\t\t\t// Below `strict_pattern` is used for the\n\t\t\t// regular expression (with `^` and `$`).\n\t\t\t// This wasn't originally in Google's `libphonenumber`\n\t\t\t// and I guess they don't really need it\n\t\t\t// because they're not using \"templates\" to format phone numbers\n\t\t\t// but I added `strict_pattern` after encountering\n\t\t\t// South Korean phone number formatting bug.\n\t\t\t//\n\t\t\t// Non-strict regular expression bug demonstration:\n\t\t\t//\n\t\t\t// this.national_number : `111111111` (9 digits)\n\t\t\t//\n\t\t\t// number_pattern : (\\d{2})(\\d{3,4})(\\d{4})\n\t\t\t// number_format : `$1 $2 $3`\n\t\t\t// dummy_phone_number_matching_format_pattern : `9999999999` (10 digits)\n\t\t\t//\n\t\t\t// '9999999999'.replace(new RegExp(/(\\d{2})(\\d{3,4})(\\d{4})/g), '$1 $2 $3') = \"99 9999 9999\"\n\t\t\t//\n\t\t\t// template : xx xxxx xxxx\n\t\t\t//\n\t\t\t// But the correct template in this case is `xx xxx xxxx`.\n\t\t\t// The template was generated incorrectly because of the\n\t\t\t// `{3,4}` variability in the `number_pattern`.\n\t\t\t//\n\t\t\t// The fix is, if `this.national_number` has already sufficient length\n\t\t\t// to satisfy the `number_pattern` completely then `this.national_number` is used\n\t\t\t// instead of `dummy_phone_number_matching_format_pattern`.\n\n\t\t\tvar strict_pattern = new RegExp('^' + number_pattern + '$');\n\t\t\tvar national_number_dummy_digits = this.national_number.replace(/\\d/g, DUMMY_DIGIT);\n\n\t\t\t// If `this.national_number` has already sufficient length\n\t\t\t// to satisfy the `number_pattern` completely then use it\n\t\t\t// instead of `dummy_phone_number_matching_format_pattern`.\n\t\t\tif (strict_pattern.test(national_number_dummy_digits)) {\n\t\t\t\tdummy_phone_number_matching_format_pattern = national_number_dummy_digits;\n\t\t\t}\n\n\t\t\t// Generate formatting template for this phone number format\n\t\t\treturn dummy_phone_number_matching_format_pattern\n\t\t\t// Format the dummy phone number according to the format\n\t\t\t.replace(new RegExp(number_pattern), number_format)\n\t\t\t// Replace each dummy digit with a DIGIT_PLACEHOLDER\n\t\t\t.replace(DUMMY_DIGIT_MATCHER, DIGIT_PLACEHOLDER);\n\t\t}\n\t}, {\n\t\tkey: 'format_next_national_number_digits',\n\t\tvalue: function format_next_national_number_digits(digits) {\n\t\t\tvar _iteratorNormalCompletion3 = true;\n\t\t\tvar _didIteratorError3 = false;\n\t\t\tvar _iteratorError3 = undefined;\n\n\t\t\ttry {\n\t\t\t\tfor (var _iterator3 = _getIterator(digits), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t\t\t\t\tvar digit = _step3.value;\n\n\t\t\t\t\t// If there is room for more digits in current `template`,\n\t\t\t\t\t// then set the next digit in the `template`,\n\t\t\t\t\t// and return the formatted digits so far.\n\n\t\t\t\t\t// If more digits are entered than the current format could handle\n\t\t\t\t\tif (this.partially_populated_template.slice(this.last_match_position + 1).search(DIGIT_PLACEHOLDER_MATCHER) === -1) {\n\t\t\t\t\t\t// Reset the current format,\n\t\t\t\t\t\t// so that the new format will be chosen\n\t\t\t\t\t\t// in a subsequent `this.choose_another_format()` call\n\t\t\t\t\t\t// later in code.\n\t\t\t\t\t\tthis.chosen_format = undefined;\n\t\t\t\t\t\tthis.template = undefined;\n\t\t\t\t\t\tthis.partially_populated_template = undefined;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.last_match_position = this.partially_populated_template.search(DIGIT_PLACEHOLDER_MATCHER);\n\t\t\t\t\tthis.partially_populated_template = this.partially_populated_template.replace(DIGIT_PLACEHOLDER_MATCHER, digit);\n\t\t\t\t}\n\n\t\t\t\t// Return the formatted phone number so far\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError3 = true;\n\t\t\t\t_iteratorError3 = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t\t\t\t\t\t_iterator3.return();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError3) {\n\t\t\t\t\t\tthrow _iteratorError3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn close_dangling_braces(this.partially_populated_template, this.last_match_position + 1).replace(DIGIT_PLACEHOLDER_MATCHER_GLOBAL, ' ');\n\t\t}\n\t}, {\n\t\tkey: 'is_international',\n\t\tvalue: function is_international() {\n\t\t\treturn this.parsed_input && this.parsed_input[0] === '+';\n\t\t}\n\t}, {\n\t\tkey: 'get_format_format',\n\t\tvalue: function get_format_format(format, national_prefix_formatting_rule) {\n\t\t\tvar number_format = this.is_international() ? get_format_international_format(format) : _get_format_format(format);\n\n\t\t\t// If national prefix formatting rule is set\n\t\t\t// for this phone number format\n\t\t\tif (national_prefix_formatting_rule) {\n\t\t\t\t// If the user did input the national prefix\n\t\t\t\t// (or if the national prefix formatting rule does not require national prefix)\n\t\t\t\t// then maybe make it part of the phone number template\n\t\t\t\tif (this.national_prefix || !get_format_uses_national_prefix(national_prefix_formatting_rule)) {\n\t\t\t\t\t// Make the national prefix part of the phone number template\n\t\t\t\t\tnumber_format = number_format.replace(FIRST_GROUP_PATTERN, national_prefix_formatting_rule);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.is_international()) {\n\t\t\t\treturn local_to_international_style(number_format);\n\t\t\t}\n\n\t\t\treturn number_format;\n\t\t}\n\n\t\t// Determines the country of the phone number\n\t\t// entered so far based on the country phone code\n\t\t// and the national phone number.\n\n\t}, {\n\t\tkey: 'determine_the_country',\n\t\tvalue: function determine_the_country() {\n\t\t\tthis.country = find_country_code(this.country_phone_code, this.national_number, this.metadata);\n\t\t}\n\t}]);\n\n\treturn as_you_type;\n}();\n\nexport default as_you_type;\n\n\nexport function close_dangling_braces(template, cut_before) {\n\tvar retained_template = template.slice(0, cut_before);\n\n\tvar opening_braces = count_occurences('(', retained_template);\n\tvar closing_braces = count_occurences(')', retained_template);\n\n\tvar dangling_braces = opening_braces - closing_braces;\n\n\twhile (dangling_braces > 0 && cut_before < template.length) {\n\t\tif (template[cut_before] === ')') {\n\t\t\tdangling_braces--;\n\t\t}\n\t\tcut_before++;\n\t}\n\n\treturn template.slice(0, cut_before);\n}\n\n// Counts all occurences of a symbol in a string\nexport function count_occurences(symbol, string) {\n\tvar count = 0;\n\n\tvar _iteratorNormalCompletion4 = true;\n\tvar _didIteratorError4 = false;\n\tvar _iteratorError4 = undefined;\n\n\ttry {\n\t\tfor (var _iterator4 = _getIterator(string), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n\t\t\tvar character = _step4.value;\n\n\t\t\tif (character === symbol) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t} catch (err) {\n\t\t_didIteratorError4 = true;\n\t\t_iteratorError4 = err;\n\t} finally {\n\t\ttry {\n\t\t\tif (!_iteratorNormalCompletion4 && _iterator4.return) {\n\t\t\t\t_iterator4.return();\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_didIteratorError4) {\n\t\t\t\tthrow _iteratorError4;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count;\n}\n\n// Repeats a string (or a symbol) N times.\n// http://stackoverflow.com/questions/202605/repeat-string-javascript\nexport function repeat(string, times) {\n\tif (times < 1) {\n\t\treturn '';\n\t}\n\n\tvar result = '';\n\n\twhile (times > 1) {\n\t\tif (times & 1) {\n\t\t\tresult += string;\n\t\t}\n\n\t\ttimes >>= 1;\n\t\tstring += string;\n\t}\n\n\treturn result + string;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}
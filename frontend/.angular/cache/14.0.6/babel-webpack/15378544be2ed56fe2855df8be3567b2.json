{"ast":null,"code":"import _extends from 'babel-runtime/helpers/extends';\nimport _slicedToArray from 'babel-runtime/helpers/slicedToArray';\nimport _getIterator from 'babel-runtime/core-js/get-iterator'; // This is a port of Google Android `libphonenumber`'s\n// `phonenumberutil.js` of 17th November, 2016.\n//\n// https://github.com/googlei18n/libphonenumber/commits/master/javascript/i18n/phonenumbers/phonenumberutil.js\n\nimport { matches_entirely } from './common';\nimport { get_phone_code, get_national_number_pattern, get_national_prefix_for_parsing, get_national_prefix_transform_rule, get_leading_digits, get_metadata_by_country_phone_code, get_formats } from // get_format_national_prefix_is_mandatory_when_formatting\n'./metadata';\nimport { choose_format_for_number } from './format';\nimport get_number_type from './types'; // The maximum length of the country calling code.\n\nvar MAX_LENGTH_COUNTRY_CODE = 3; // The minimum length of the national significant number.\n\nvar MIN_LENGTH_FOR_NSN = 2; // The ITU says the maximum length should be 15,\n// but one can find longer numbers in Germany.\n\nvar MAX_LENGTH_FOR_NSN = 17; // We don't allow input strings for parsing to be longer than 250 chars.\n// This prevents malicious input from consuming CPU.\n\nvar MAX_INPUT_STRING_LENGTH = 250;\nexport var PLUS_CHARS = '+\\uFF0B'; // Digits accepted in phone numbers\n// (ascii, fullwidth, arabic-indic, and eastern arabic digits).\n\nexport var VALID_DIGITS = '0-9\\uFF10-\\uFF19\\u0660-\\u0669\\u06F0-\\u06F9'; // `DASHES` will be right after the opening square bracket of the \"character class\"\n\nvar DASHES = '-\\u2010-\\u2015\\u2212\\u30FC\\uFF0D';\nvar SLASHES = '\\uFF0F/';\nvar DOTS = '\\uFF0E.';\nvar WHITESPACE = ' \\xA0\\xAD\\u200B\\u2060\\u3000';\nvar BRACKETS = '()\\uFF08\\uFF09\\uFF3B\\uFF3D\\\\[\\\\]';\nvar TILDES = '~\\u2053\\u223C\\uFF5E'; // Regular expression of acceptable punctuation found in phone numbers. This\n// excludes punctuation found as a leading character only. This consists of dash\n// characters, white space characters, full stops, slashes, square brackets,\n// parentheses and tildes. Full-width variants are also present.\n\nexport var VALID_PUNCTUATION = '' + DASHES + SLASHES + DOTS + WHITESPACE + BRACKETS + TILDES; // Pattern to capture digits used in an extension.\n// Places a maximum length of '7' for an extension.\n\nvar CAPTURING_EXTN_DIGITS = '([' + VALID_DIGITS + ']{1,7})'; // The RFC 3966 format for extensions.\n\nvar RFC3966_EXTN_PREFIX = ';ext=';\n/**\r\n * Regexp of all possible ways to write extensions, for use when parsing. This\r\n * will be run as a case-insensitive regexp match. Wide character versions are\r\n * also provided after each ASCII version. There are three regular expressions\r\n * here. The first covers RFC 3966 format, where the extension is added using\r\n * ';ext='. The second more generic one starts with optional white space and\r\n * ends with an optional full stop (.), followed by zero or more spaces/tabs\r\n * /commas and then the numbers themselves. The other one covers the special\r\n * case of American numbers where the extension is written with a hash at the\r\n * end, such as '- 503#'. Note that the only capturing groups should be around\r\n * the digits that you want to capture as part of the extension, or else parsing\r\n * will fail! We allow two options for representing the accented o - the\r\n * character itself, and one in the unicode decomposed form with the combining\r\n * acute accent.\r\n */\n\nvar EXTN_PATTERNS_FOR_PARSING = RFC3966_EXTN_PREFIX + CAPTURING_EXTN_DIGITS + '|' + '[ \\xA0\\\\t,]*' + '(?:e?xt(?:ensi(?:o\\u0301?|\\xF3))?n?|\\uFF45?\\uFF58\\uFF54\\uFF4E?|' + '[;,x\\uFF58#\\uFF03~\\uFF5E]|int|anexo|\\uFF49\\uFF4E\\uFF54)' + '[:\\\\.\\uFF0E]?[ \\xA0\\\\t,-]*' + CAPTURING_EXTN_DIGITS + '#?|' + '[- ]+([' + VALID_DIGITS + ']{1,5})#'; // Regexp of all known extension prefixes used by different regions followed by\n// 1 or more valid digits, for use when parsing.\n\nvar EXTN_PATTERN = new RegExp('(?:' + EXTN_PATTERNS_FOR_PARSING + ')$', 'i'); //  Regular expression of viable phone numbers. This is location independent.\n//  Checks we have at least three leading digits, and only valid punctuation,\n//  alpha characters and digits in the phone number. Does not include extension\n//  data. The symbol 'x' is allowed here as valid punctuation since it is often\n//  used as a placeholder for carrier codes, for example in Brazilian phone\n//  numbers. We also allow multiple '+' characters at the start.\n//\n//  Corresponds to the following:\n//  [digits]{minLengthNsn}|\n//  plus_sign*\n//  (([punctuation]|[star])*[digits]){3,}([punctuation]|[star]|[digits]|[alpha])*\n//\n//  The first reg-ex is to allow short numbers (two digits long) to be parsed if\n//  they are entered as \"15\" etc, but only if there is no punctuation in them.\n//  The second expression restricts the number of digits to three or more, but\n//  then allows them to be in international form, and to have alpha-characters\n//  and punctuation. We split up the two reg-exes here and combine them when\n//  creating the reg-ex VALID_PHONE_NUMBER_PATTERN itself so we can prefix it\n//  with ^ and append $ to each branch.\n//\n//  \"Note VALID_PUNCTUATION starts with a -,\n//   so must be the first in the range\" (c) Google devs.\n//  (wtf did they mean by saying that; probably nothing)\n//\n\nvar MIN_LENGTH_PHONE_NUMBER_PATTERN = '[' + VALID_DIGITS + ']{' + MIN_LENGTH_FOR_NSN + '}'; //\n// And this is the second reg-exp:\n// (see MIN_LENGTH_PHONE_NUMBER_PATTERN for a full description of this reg-exp)\n//\n\nvar VALID_PHONE_NUMBER = '[' + PLUS_CHARS + ']{0,1}' + '(?:' + '[' + VALID_PUNCTUATION + ']*' + '[' + VALID_DIGITS + ']' + '){3,}' + '[' + VALID_PUNCTUATION + VALID_DIGITS + ']*'; // The combined regular expression for valid phone numbers:\n//\n\nvar VALID_PHONE_NUMBER_PATTERN = new RegExp( // Either a short two-digit-only phone number\n'^' + MIN_LENGTH_PHONE_NUMBER_PATTERN + '$' + '|' + // Or a longer fully parsed phone number (min 3 characters)\n'^' + VALID_PHONE_NUMBER + // Phone number extensions\n'(?:' + EXTN_PATTERNS_FOR_PARSING + ')?' + '$', 'i'); // This consists of the plus symbol, digits, and arabic-indic digits.\n\nvar PHONE_NUMBER_START_PATTERN = new RegExp('[' + PLUS_CHARS + VALID_DIGITS + ']'); // Regular expression of trailing characters that we want to remove.\n\nvar AFTER_PHONE_NUMBER_END_PATTERN = new RegExp('[^' + VALID_DIGITS + ']+$');\nvar LEADING_PLUS_CHARS_PATTERN = new RegExp('^[' + PLUS_CHARS + ']+'); // These mappings map a character (key) to a specific digit that should\n// replace it for normalization purposes. Non-European digits that\n// may be used in phone numbers are mapped to a European equivalent.\n//\n// E.g. in Iraq they don't write `+442323234` but rather `+٤٤٢٣٢٣٢٣٤`.\n//\n\nexport var DIGIT_MAPPINGS = {\n  '0': '0',\n  '1': '1',\n  '2': '2',\n  '3': '3',\n  '4': '4',\n  '5': '5',\n  '6': '6',\n  '7': '7',\n  '8': '8',\n  '9': '9',\n  '\\uFF10': '0',\n  // Fullwidth digit 0\n  '\\uFF11': '1',\n  // Fullwidth digit 1\n  '\\uFF12': '2',\n  // Fullwidth digit 2\n  '\\uFF13': '3',\n  // Fullwidth digit 3\n  '\\uFF14': '4',\n  // Fullwidth digit 4\n  '\\uFF15': '5',\n  // Fullwidth digit 5\n  '\\uFF16': '6',\n  // Fullwidth digit 6\n  '\\uFF17': '7',\n  // Fullwidth digit 7\n  '\\uFF18': '8',\n  // Fullwidth digit 8\n  '\\uFF19': '9',\n  // Fullwidth digit 9\n  '\\u0660': '0',\n  // Arabic-indic digit 0\n  '\\u0661': '1',\n  // Arabic-indic digit 1\n  '\\u0662': '2',\n  // Arabic-indic digit 2\n  '\\u0663': '3',\n  // Arabic-indic digit 3\n  '\\u0664': '4',\n  // Arabic-indic digit 4\n  '\\u0665': '5',\n  // Arabic-indic digit 5\n  '\\u0666': '6',\n  // Arabic-indic digit 6\n  '\\u0667': '7',\n  // Arabic-indic digit 7\n  '\\u0668': '8',\n  // Arabic-indic digit 8\n  '\\u0669': '9',\n  // Arabic-indic digit 9\n  '\\u06F0': '0',\n  // Eastern-Arabic digit 0\n  '\\u06F1': '1',\n  // Eastern-Arabic digit 1\n  '\\u06F2': '2',\n  // Eastern-Arabic digit 2\n  '\\u06F3': '3',\n  // Eastern-Arabic digit 3\n  '\\u06F4': '4',\n  // Eastern-Arabic digit 4\n  '\\u06F5': '5',\n  // Eastern-Arabic digit 5\n  '\\u06F6': '6',\n  // Eastern-Arabic digit 6\n  '\\u06F7': '7',\n  // Eastern-Arabic digit 7\n  '\\u06F8': '8',\n  // Eastern-Arabic digit 8\n  '\\u06F9': '9' // Eastern-Arabic digit 9\n\n};\nvar default_options = {\n  country: {} // `options`:\n  //  {\n  //    country:\n  //    {\n  //      restrict - (a two-letter country code)\n  //                 the phone number must be in this country\n  //\n  //      default - (a two-letter country code)\n  //                default country to use for phone number parsing and validation\n  //                (if no country code could be derived from the phone number)\n  //    }\n  //  }\n  //\n  // Returns `{ country, number }`\n  //\n  // Example use cases:\n  //\n  // ```js\n  // parse('8 (800) 555-35-35', 'RU')\n  // parse('8 (800) 555-35-35', 'RU', metadata)\n  // parse('8 (800) 555-35-35', { country: { default: 'RU' } })\n  // parse('8 (800) 555-35-35', { country: { default: 'RU' } }, metadata)\n  // parse('+7 800 555 35 35')\n  // parse('+7 800 555 35 35', metadata)\n  // ```\n  //\n\n};\nexport default function parse(arg_1, arg_2, arg_3) {\n  var _sort_out_arguments = sort_out_arguments(arg_1, arg_2, arg_3),\n      text = _sort_out_arguments.text,\n      options = _sort_out_arguments.options,\n      metadata = _sort_out_arguments.metadata; // Validate country codes\n  // Validate `default` country\n\n\n  if (options.country.default && !metadata.countries[options.country.default]) {\n    throw new Error('Unknown country code: ' + options.country.default);\n  } // Validate `restrict` country\n\n\n  if (options.country.restrict && !metadata.countries[options.country.restrict]) {\n    throw new Error('Unknown country code: ' + options.country.restrict);\n  } // Parse the phone number\n\n\n  var formatted_phone_number = void 0;\n  var extension = void 0; // Parse RFC 3966 phone number URI.\n\n  if (text && text.indexOf('tel:') === 0) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = _getIterator(text.split(';')), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var part = _step.value;\n\n        var _part$split = part.split(':'),\n            _part$split2 = _slicedToArray(_part$split, 2),\n            name = _part$split2[0],\n            value = _part$split2[1];\n\n        switch (name) {\n          case 'tel':\n            formatted_phone_number = value;\n            break;\n\n          case 'ext':\n            extension = value;\n            break;\n\n          case 'phone-context':\n            // Domain contexts are ignored.\n            if (value[0] === '+') {\n              formatted_phone_number = value + formatted_phone_number;\n            }\n\n            break;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  } else {\n    formatted_phone_number = extract_formatted_phone_number(text);\n  } // If the phone number is not viable, then abort.\n\n\n  if (!is_viable_phone_number(formatted_phone_number)) {\n    return {};\n  } // Attempt to parse extension first, since it doesn't require region-specific\n  // data and we want to have the non-normalised number here.\n\n\n  var with_extension_stripped = strip_extension(formatted_phone_number);\n\n  if (with_extension_stripped.extension) {\n    formatted_phone_number = with_extension_stripped.number, extension = with_extension_stripped.extension;\n  }\n\n  var _parse_phone_number_a = parse_phone_number_and_country_phone_code(formatted_phone_number, metadata),\n      country_phone_code = _parse_phone_number_a.country_phone_code,\n      number = _parse_phone_number_a.number; // Maybe invalid country phone code encountered\n\n\n  if (!number) {\n    return {};\n  }\n\n  var country = void 0;\n  var country_metadata = void 0; // Whether the phone number is formatted as an international phone number\n\n  var is_international = false;\n\n  if (country_phone_code) {\n    is_international = true; // Check country restriction\n\n    if (options.country.restrict && country_phone_code !== get_phone_code(metadata.countries[options.country.restrict])) {\n      return {};\n    } // Formatting information for regions which share\n    // a country calling code is contained by only one region\n    // for performance reasons. For example, for NANPA region\n    // (\"North American Numbering Plan Administration\",\n    //  which includes USA, Canada, Cayman Islands, Bahamas, etc)\n    // it will be contained in the metadata for `US`.\n\n\n    country_metadata = get_metadata_by_country_phone_code(country_phone_code, metadata); // `country` will be set later,\n    // because, for example, for NANPA countries\n    // there are several countries corresponding\n    // to the same `1` country phone code.\n    // Therefore, to reliably determine the exact country,\n    // national (significant) number should be parsed first.\n  } else if (options.country.restrict || options.country.default) {\n    country = options.country.restrict || options.country.default;\n    country_metadata = metadata.countries[country];\n    number = normalize(formatted_phone_number);\n  }\n\n  if (!country_metadata) {\n    return {};\n  }\n\n  var national_number = number; // Only strip national prefixes for non-international phone numbers\n  // because national prefixes can't be present in international phone numbers.\n  // Otherwise, while forgiving, it would parse a NANPA number `+1 1877 215 5230`\n  // first to `1877 215 5230` and then, stripping the leading `1`, to `877 215 5230`,\n  // and then it would assume that's a valid number which it isn't.\n  // So no forgiveness for grandmas here.\n  // The issue asking for this fix:\n  // https://github.com/catamphetamine/libphonenumber-js/issues/159\n\n  if (!is_international) {\n    national_number = strip_national_prefix(number, country_metadata);\n  }\n\n  var did_have_national_prefix = national_number !== number; // https://github.com/catamphetamine/libphonenumber-js/issues/67\n  // if (!is_international && !did_have_national_prefix &&\n  // \t\tis_national_prefix_required(national_number, country_metadata))\n  // {\n  // \treturn {}\n  // }\n  // Sometimes there are several countries\n  // corresponding to the same country phone code\n  // (e.g. NANPA countries all having `1` country phone code).\n  // Therefore, to reliably determine the exact country,\n  // national (significant) number should have been parsed first.\n  //\n\n  if (!country) {\n    // When `metadata.json` is generated, all \"ambiguous\" country phone codes\n    // get their countries populated with the full set of\n    // \"phone number type\" regular expressions.\n    country = find_country_code(country_phone_code, national_number, metadata); // Just in case there appears to be a bug in Google's metadata\n    // and the exact country could not be extracted from the phone number.\n\n    /* istanbul ignore if */\n\n    if (!country) {\n      return {};\n    } // Update metadata to be for this specific country\n\n\n    country_metadata = metadata.countries[country];\n  } // Validate national (significant) number length.\n  //\n  // A sidenote:\n  //\n  // They say that sometimes national (significant) numbers\n  // can be longer than `MAX_LENGTH_FOR_NSN` (e.g. in Germany).\n  // https://github.com/googlei18n/libphonenumber/blob/7e1748645552da39c4e1ba731e47969d97bdb539/resources/phonenumber.proto#L36\n  // Such numbers will just be discarded.\n  //\n\n\n  if (national_number.length > MAX_LENGTH_FOR_NSN) {\n    return {};\n  } // National number pattern is different for each country,\n  // even for those ones which are part of the \"NANPA\" group.\n\n\n  var national_number_rule = new RegExp(get_national_number_pattern(country_metadata)); // Check if national phone number pattern matches the number\n\n  if (!matches_entirely(national_number, national_number_rule)) {\n    return {};\n  }\n\n  var result = {\n    country: country,\n    phone: national_number\n  };\n\n  if (extension) {\n    result.ext = extension;\n  }\n\n  return result;\n} // Normalizes a string of characters representing a phone number.\n// This converts wide-ascii and arabic-indic numerals to European numerals,\n// and strips punctuation and alpha characters.\n//\n// E.g. in Iraq they don't write `+442323234` but rather `+٤٤٢٣٢٣٢٣٤`.\n//\n\nexport function normalize(number) {\n  return replace_characters(number, DIGIT_MAPPINGS);\n} // For any character not being part of `replacements`\n// it is removed from the phone number.\n\nexport function replace_characters(text, replacements) {\n  var replaced = '';\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = _getIterator(text), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var character = _step2.value;\n      var replacement = replacements[character.toUpperCase()];\n\n      if (replacement !== undefined) {\n        replaced += replacement;\n      }\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  return replaced;\n} // Checks to see if the string of characters could possibly be a phone number at\n// all. At the moment, checks to see that the string begins with at least 2\n// digits, ignoring any punctuation commonly found in phone numbers. This method\n// does not require the number to be normalized in advance - but does assume\n// that leading non-number symbols have been removed, such as by the method\n// `extract_possible_number`.\n//\n\nexport function is_viable_phone_number(number) {\n  return number.length >= MIN_LENGTH_FOR_NSN && matches_entirely(number, VALID_PHONE_NUMBER_PATTERN);\n}\nexport function extract_formatted_phone_number(text) {\n  if (!text || text.length > MAX_INPUT_STRING_LENGTH) {\n    return '';\n  } // Attempt to extract a possible number from the string passed in\n\n\n  var starts_at = text.search(PHONE_NUMBER_START_PATTERN);\n\n  if (starts_at < 0) {\n    return '';\n  }\n\n  return text // Trim everything to the left of the phone number\n  .slice(starts_at) // Remove trailing non-numerical characters\n  .replace(AFTER_PHONE_NUMBER_END_PATTERN, '');\n} // Parses a formatted phone number.\n\nexport function parse_phone_number(number) {\n  if (!number) {\n    return '';\n  }\n\n  var is_international = LEADING_PLUS_CHARS_PATTERN.test(number); // Remove non-digits\n  // (and strip the possible leading '+')\n\n  number = normalize(number);\n\n  if (is_international) {\n    return '+' + number;\n  }\n\n  return number;\n} // Parses a formatted phone number\n// and returns `{ country_phone_code, number }`\n// where `number` is the national (significant) phone number.\n//\n// (aka `maybeExtractCountryPhoneCode`)\n//\n\nexport function parse_phone_number_and_country_phone_code(number, metadata) {\n  number = parse_phone_number(number);\n\n  if (!number) {\n    return {};\n  } // If this is not an international phone number,\n  // then don't extract country phone code.\n\n\n  if (number[0] !== '+') {\n    return {\n      number: number\n    };\n  } // Strip the leading '+' sign\n\n\n  number = number.slice(1); // Fast abortion: country codes do not begin with a '0'\n\n  if (number[0] === '0') {\n    return {};\n  } // The thing with country phone codes\n  // is that they are orthogonal to each other\n  // i.e. there's no such country phone code A\n  // for which country phone code B exists\n  // where B starts with A.\n  // Therefore, while scanning digits,\n  // if a valid country code is found,\n  // that means that it is the country code.\n  //\n\n\n  var i = 1;\n\n  while (i <= MAX_LENGTH_COUNTRY_CODE && i <= number.length) {\n    var country_phone_code = number.slice(0, i);\n\n    if (metadata.country_phone_code_to_countries[country_phone_code]) {\n      return {\n        country_phone_code: country_phone_code,\n        number: number.slice(i)\n      };\n    }\n\n    i++;\n  }\n\n  return {};\n} // Strips any national prefix (such as 0, 1) present in the number provided\n\nexport function strip_national_prefix(number, country_metadata) {\n  var national_prefix_for_parsing = get_national_prefix_for_parsing(country_metadata);\n\n  if (!number || !national_prefix_for_parsing) {\n    return number;\n  } // Attempt to parse the first digits as a national prefix\n\n\n  var national_prefix_pattern = new RegExp('^(?:' + national_prefix_for_parsing + ')');\n  var national_prefix_matcher = national_prefix_pattern.exec(number); // If no national prefix is present in the phone number,\n  // but if the national prefix is optional for this country,\n  // then consider this phone number valid.\n  //\n  // Google's reference `libphonenumber` implementation\n  // wouldn't recognize such phone numbers as valid,\n  // but I think it would perfectly make sense\n  // to consider such phone numbers as valid\n  // because if a national phone number was originally\n  // formatted without the national prefix\n  // then it must be parseable back into the original national number.\n  // In other words, `parse(format(number))`\n  // must always be equal to `number`.\n  //\n\n  if (!national_prefix_matcher) {\n    return number;\n  }\n\n  var national_significant_number = void 0; // `national_prefix_for_parsing` capturing groups\n  // (used only for really messy cases: Argentina, Brazil, Mexico, Somalia)\n\n  var any_groups_were_captured = national_prefix_matcher[national_prefix_matcher.length - 1];\n  var national_prefix_transform_rule = get_national_prefix_transform_rule(country_metadata); // If the national number tranformation is needed then do it\n\n  if (national_prefix_transform_rule && any_groups_were_captured) {\n    national_significant_number = number.replace(national_prefix_pattern, national_prefix_transform_rule);\n  } // Else, no transformation is necessary,\n  // and just strip the national prefix.\n  else {\n    national_significant_number = number.slice(national_prefix_matcher[0].length);\n  } // Verify the parsed national (significant) number for this country\n\n\n  var national_number_rule = new RegExp(get_national_number_pattern(country_metadata)); // If the original number (before stripping national prefix) was viable,\n  // and the resultant number is not, then prefer the original phone number.\n  // This is because for some countries (e.g. Russia) the same digit could be both\n  // a national prefix and a leading digit of a valid national phone number,\n  // like `8` is the national prefix for Russia and both\n  // `8 800 555 35 35` and `800 555 35 35` are valid numbers.\n\n  if (matches_entirely(number, national_number_rule) && !matches_entirely(national_significant_number, national_number_rule)) {\n    return number;\n  } // Return the parsed national (significant) number\n\n\n  return national_significant_number;\n}\nexport function find_country_code(country_phone_code, national_phone_number, metadata) {\n  // Is always non-empty, because `country_phone_code` is always valid\n  var possible_countries = metadata.country_phone_code_to_countries[country_phone_code]; // If there's just one country corresponding to the country code,\n  // then just return it, without further phone number digits validation.\n\n  if (possible_countries.length === 1) {\n    return possible_countries[0];\n  }\n\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = _getIterator(possible_countries), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var country_code = _step3.value;\n      var country = metadata.countries[country_code]; // Leading digits check would be the simplest one\n\n      if (get_leading_digits(country)) {\n        if (national_phone_number && national_phone_number.search(get_leading_digits(country)) === 0) {\n          return country_code;\n        }\n      } // Else perform full validation with all of those bulky\n      // fixed-line/mobile/etc regular expressions.\n      else if (get_number_type({\n        phone: national_phone_number,\n        country: country_code\n      }, metadata)) {\n        return country_code;\n      }\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n} // export function is_national_prefix_required(national_number, country_metadata)\n// {\n// \tconst format = choose_format_for_number(get_formats(country_metadata), national_number)\n//\n// \tif (format)\n// \t{\n// \t\treturn get_format_national_prefix_is_mandatory_when_formatting(format, country_metadata)\n// \t}\n// }\n// Sort out arguments\n\nfunction sort_out_arguments(arg_1, arg_2, arg_3) {\n  var text = void 0;\n  var options = void 0;\n  var metadata = void 0; // Normalize numerical `value`.\n  // https://github.com/catamphetamine/libphonenumber-js/issues/142\n  // `parse(88005553535, ...)`.\n\n  if (typeof arg_1 === 'number') {\n    arg_1 = String(arg_1);\n  } // If the phone number is passed as a string.\n  // `parse('88005553535', ...)`.\n\n\n  if (typeof arg_1 === 'string') {\n    text = arg_1;\n  } // If \"resrict country\" argument is being passed\n  // then convert it to an `options` object.\n  // `parse('88005553535', 'RU', [options], metadata)`.\n\n\n  if (typeof arg_2 === 'string') {\n    options = {\n      country: {\n        restrict: arg_2\n      }\n    };\n    metadata = arg_3;\n  } // No \"resrict country\" argument is being passed.\n  // International phone number is passed.\n  // `parse('+78005553535', [options], metadata)`.\n  else {\n    if (arg_3) {\n      options = arg_2;\n      metadata = arg_3;\n    } else {\n      metadata = arg_2;\n    }\n  } // Metadata is required.\n\n\n  if (!metadata || !metadata.countries) {\n    throw new Error('Metadata is required');\n  } // Apply default options.\n\n\n  if (options) {\n    options = _extends({}, default_options, options);\n  } else {\n    options = default_options;\n  }\n\n  return {\n    text: text,\n    options: options,\n    metadata: metadata\n  };\n} // Strips any extension (as in, the part of the number dialled after the call is\n// connected, usually indicated with extn, ext, x or similar) from the end of\n// the number, and returns it.\n\n\nfunction strip_extension(number) {\n  var start = number.search(EXTN_PATTERN);\n\n  if (start < 0) {\n    return {};\n  } // If we find a potential extension, and the number preceding this is a viable\n  // number, we assume it is an extension.\n\n\n  var number_without_extension = number.slice(0, start);\n  /* istanbul ignore if - seems a bit of a redundant check */\n\n  if (!is_viable_phone_number(number_without_extension)) {\n    return {};\n  }\n\n  var matches = number.match(EXTN_PATTERN);\n  var i = 1;\n\n  while (i < matches.length) {\n    if (matches[i] != null && matches[i].length > 0) {\n      return {\n        number: number_without_extension,\n        extension: matches[i]\n      };\n    }\n\n    i++;\n  }\n}","map":{"version":3,"names":["_extends","_slicedToArray","_getIterator","matches_entirely","get_phone_code","get_national_number_pattern","get_national_prefix_for_parsing","get_national_prefix_transform_rule","get_leading_digits","get_metadata_by_country_phone_code","get_formats","choose_format_for_number","get_number_type","MAX_LENGTH_COUNTRY_CODE","MIN_LENGTH_FOR_NSN","MAX_LENGTH_FOR_NSN","MAX_INPUT_STRING_LENGTH","PLUS_CHARS","VALID_DIGITS","DASHES","SLASHES","DOTS","WHITESPACE","BRACKETS","TILDES","VALID_PUNCTUATION","CAPTURING_EXTN_DIGITS","RFC3966_EXTN_PREFIX","EXTN_PATTERNS_FOR_PARSING","EXTN_PATTERN","RegExp","MIN_LENGTH_PHONE_NUMBER_PATTERN","VALID_PHONE_NUMBER","VALID_PHONE_NUMBER_PATTERN","PHONE_NUMBER_START_PATTERN","AFTER_PHONE_NUMBER_END_PATTERN","LEADING_PLUS_CHARS_PATTERN","DIGIT_MAPPINGS","default_options","country","parse","arg_1","arg_2","arg_3","_sort_out_arguments","sort_out_arguments","text","options","metadata","default","countries","Error","restrict","formatted_phone_number","extension","indexOf","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","split","_step","next","done","part","value","_part$split","_part$split2","name","err","return","extract_formatted_phone_number","is_viable_phone_number","with_extension_stripped","strip_extension","number","_parse_phone_number_a","parse_phone_number_and_country_phone_code","country_phone_code","country_metadata","is_international","normalize","national_number","strip_national_prefix","did_have_national_prefix","find_country_code","length","national_number_rule","result","phone","ext","replace_characters","replacements","replaced","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","character","replacement","toUpperCase","starts_at","search","slice","replace","parse_phone_number","test","i","country_phone_code_to_countries","national_prefix_for_parsing","national_prefix_pattern","national_prefix_matcher","exec","national_significant_number","any_groups_were_captured","national_prefix_transform_rule","national_phone_number","possible_countries","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_iterator3","_step3","country_code","String","start","number_without_extension","matches","match"],"sources":["/usr/src/app/node_modules/libphonenumber-js/es6/parse.js"],"sourcesContent":["import _extends from 'babel-runtime/helpers/extends';\nimport _slicedToArray from 'babel-runtime/helpers/slicedToArray';\nimport _getIterator from 'babel-runtime/core-js/get-iterator';\n// This is a port of Google Android `libphonenumber`'s\n// `phonenumberutil.js` of 17th November, 2016.\n//\n// https://github.com/googlei18n/libphonenumber/commits/master/javascript/i18n/phonenumbers/phonenumberutil.js\n\nimport { matches_entirely } from './common';\n\nimport { get_phone_code, get_national_number_pattern, get_national_prefix_for_parsing, get_national_prefix_transform_rule, get_leading_digits, get_metadata_by_country_phone_code, get_formats } from\n// get_format_national_prefix_is_mandatory_when_formatting\n'./metadata';\n\nimport { choose_format_for_number } from './format';\n\nimport get_number_type from './types';\n\n// The maximum length of the country calling code.\nvar MAX_LENGTH_COUNTRY_CODE = 3;\n\n// The minimum length of the national significant number.\nvar MIN_LENGTH_FOR_NSN = 2;\n\n// The ITU says the maximum length should be 15,\n// but one can find longer numbers in Germany.\nvar MAX_LENGTH_FOR_NSN = 17;\n\n// We don't allow input strings for parsing to be longer than 250 chars.\n// This prevents malicious input from consuming CPU.\nvar MAX_INPUT_STRING_LENGTH = 250;\n\nexport var PLUS_CHARS = '+\\uFF0B';\n\n// Digits accepted in phone numbers\n// (ascii, fullwidth, arabic-indic, and eastern arabic digits).\nexport var VALID_DIGITS = '0-9\\uFF10-\\uFF19\\u0660-\\u0669\\u06F0-\\u06F9';\n\n// `DASHES` will be right after the opening square bracket of the \"character class\"\nvar DASHES = '-\\u2010-\\u2015\\u2212\\u30FC\\uFF0D';\nvar SLASHES = '\\uFF0F/';\nvar DOTS = '\\uFF0E.';\nvar WHITESPACE = ' \\xA0\\xAD\\u200B\\u2060\\u3000';\nvar BRACKETS = '()\\uFF08\\uFF09\\uFF3B\\uFF3D\\\\[\\\\]';\nvar TILDES = '~\\u2053\\u223C\\uFF5E';\n\n// Regular expression of acceptable punctuation found in phone numbers. This\n// excludes punctuation found as a leading character only. This consists of dash\n// characters, white space characters, full stops, slashes, square brackets,\n// parentheses and tildes. Full-width variants are also present.\nexport var VALID_PUNCTUATION = '' + DASHES + SLASHES + DOTS + WHITESPACE + BRACKETS + TILDES;\n\n// Pattern to capture digits used in an extension.\n// Places a maximum length of '7' for an extension.\nvar CAPTURING_EXTN_DIGITS = '([' + VALID_DIGITS + ']{1,7})';\n\n// The RFC 3966 format for extensions.\nvar RFC3966_EXTN_PREFIX = ';ext=';\n\n/**\r\n * Regexp of all possible ways to write extensions, for use when parsing. This\r\n * will be run as a case-insensitive regexp match. Wide character versions are\r\n * also provided after each ASCII version. There are three regular expressions\r\n * here. The first covers RFC 3966 format, where the extension is added using\r\n * ';ext='. The second more generic one starts with optional white space and\r\n * ends with an optional full stop (.), followed by zero or more spaces/tabs\r\n * /commas and then the numbers themselves. The other one covers the special\r\n * case of American numbers where the extension is written with a hash at the\r\n * end, such as '- 503#'. Note that the only capturing groups should be around\r\n * the digits that you want to capture as part of the extension, or else parsing\r\n * will fail! We allow two options for representing the accented o - the\r\n * character itself, and one in the unicode decomposed form with the combining\r\n * acute accent.\r\n */\nvar EXTN_PATTERNS_FOR_PARSING = RFC3966_EXTN_PREFIX + CAPTURING_EXTN_DIGITS + '|' + '[ \\xA0\\\\t,]*' + '(?:e?xt(?:ensi(?:o\\u0301?|\\xF3))?n?|\\uFF45?\\uFF58\\uFF54\\uFF4E?|' + '[;,x\\uFF58#\\uFF03~\\uFF5E]|int|anexo|\\uFF49\\uFF4E\\uFF54)' + '[:\\\\.\\uFF0E]?[ \\xA0\\\\t,-]*' + CAPTURING_EXTN_DIGITS + '#?|' + '[- ]+([' + VALID_DIGITS + ']{1,5})#';\n\n// Regexp of all known extension prefixes used by different regions followed by\n// 1 or more valid digits, for use when parsing.\nvar EXTN_PATTERN = new RegExp('(?:' + EXTN_PATTERNS_FOR_PARSING + ')$', 'i');\n\n//  Regular expression of viable phone numbers. This is location independent.\n//  Checks we have at least three leading digits, and only valid punctuation,\n//  alpha characters and digits in the phone number. Does not include extension\n//  data. The symbol 'x' is allowed here as valid punctuation since it is often\n//  used as a placeholder for carrier codes, for example in Brazilian phone\n//  numbers. We also allow multiple '+' characters at the start.\n//\n//  Corresponds to the following:\n//  [digits]{minLengthNsn}|\n//  plus_sign*\n//  (([punctuation]|[star])*[digits]){3,}([punctuation]|[star]|[digits]|[alpha])*\n//\n//  The first reg-ex is to allow short numbers (two digits long) to be parsed if\n//  they are entered as \"15\" etc, but only if there is no punctuation in them.\n//  The second expression restricts the number of digits to three or more, but\n//  then allows them to be in international form, and to have alpha-characters\n//  and punctuation. We split up the two reg-exes here and combine them when\n//  creating the reg-ex VALID_PHONE_NUMBER_PATTERN itself so we can prefix it\n//  with ^ and append $ to each branch.\n//\n//  \"Note VALID_PUNCTUATION starts with a -,\n//   so must be the first in the range\" (c) Google devs.\n//  (wtf did they mean by saying that; probably nothing)\n//\nvar MIN_LENGTH_PHONE_NUMBER_PATTERN = '[' + VALID_DIGITS + ']{' + MIN_LENGTH_FOR_NSN + '}';\n//\n// And this is the second reg-exp:\n// (see MIN_LENGTH_PHONE_NUMBER_PATTERN for a full description of this reg-exp)\n//\nvar VALID_PHONE_NUMBER = '[' + PLUS_CHARS + ']{0,1}' + '(?:' + '[' + VALID_PUNCTUATION + ']*' + '[' + VALID_DIGITS + ']' + '){3,}' + '[' + VALID_PUNCTUATION + VALID_DIGITS + ']*';\n\n// The combined regular expression for valid phone numbers:\n//\nvar VALID_PHONE_NUMBER_PATTERN = new RegExp(\n// Either a short two-digit-only phone number\n'^' + MIN_LENGTH_PHONE_NUMBER_PATTERN + '$' + '|' +\n// Or a longer fully parsed phone number (min 3 characters)\n'^' + VALID_PHONE_NUMBER +\n// Phone number extensions\n'(?:' + EXTN_PATTERNS_FOR_PARSING + ')?' + '$', 'i');\n\n// This consists of the plus symbol, digits, and arabic-indic digits.\nvar PHONE_NUMBER_START_PATTERN = new RegExp('[' + PLUS_CHARS + VALID_DIGITS + ']');\n\n// Regular expression of trailing characters that we want to remove.\nvar AFTER_PHONE_NUMBER_END_PATTERN = new RegExp('[^' + VALID_DIGITS + ']+$');\n\nvar LEADING_PLUS_CHARS_PATTERN = new RegExp('^[' + PLUS_CHARS + ']+');\n\n// These mappings map a character (key) to a specific digit that should\n// replace it for normalization purposes. Non-European digits that\n// may be used in phone numbers are mapped to a European equivalent.\n//\n// E.g. in Iraq they don't write `+442323234` but rather `+٤٤٢٣٢٣٢٣٤`.\n//\nexport var DIGIT_MAPPINGS = {\n\t'0': '0',\n\t'1': '1',\n\t'2': '2',\n\t'3': '3',\n\t'4': '4',\n\t'5': '5',\n\t'6': '6',\n\t'7': '7',\n\t'8': '8',\n\t'9': '9',\n\t'\\uFF10': '0', // Fullwidth digit 0\n\t'\\uFF11': '1', // Fullwidth digit 1\n\t'\\uFF12': '2', // Fullwidth digit 2\n\t'\\uFF13': '3', // Fullwidth digit 3\n\t'\\uFF14': '4', // Fullwidth digit 4\n\t'\\uFF15': '5', // Fullwidth digit 5\n\t'\\uFF16': '6', // Fullwidth digit 6\n\t'\\uFF17': '7', // Fullwidth digit 7\n\t'\\uFF18': '8', // Fullwidth digit 8\n\t'\\uFF19': '9', // Fullwidth digit 9\n\t'\\u0660': '0', // Arabic-indic digit 0\n\t'\\u0661': '1', // Arabic-indic digit 1\n\t'\\u0662': '2', // Arabic-indic digit 2\n\t'\\u0663': '3', // Arabic-indic digit 3\n\t'\\u0664': '4', // Arabic-indic digit 4\n\t'\\u0665': '5', // Arabic-indic digit 5\n\t'\\u0666': '6', // Arabic-indic digit 6\n\t'\\u0667': '7', // Arabic-indic digit 7\n\t'\\u0668': '8', // Arabic-indic digit 8\n\t'\\u0669': '9', // Arabic-indic digit 9\n\t'\\u06F0': '0', // Eastern-Arabic digit 0\n\t'\\u06F1': '1', // Eastern-Arabic digit 1\n\t'\\u06F2': '2', // Eastern-Arabic digit 2\n\t'\\u06F3': '3', // Eastern-Arabic digit 3\n\t'\\u06F4': '4', // Eastern-Arabic digit 4\n\t'\\u06F5': '5', // Eastern-Arabic digit 5\n\t'\\u06F6': '6', // Eastern-Arabic digit 6\n\t'\\u06F7': '7', // Eastern-Arabic digit 7\n\t'\\u06F8': '8', // Eastern-Arabic digit 8\n\t'\\u06F9': '9' // Eastern-Arabic digit 9\n};\n\nvar default_options = {\n\tcountry: {}\n\n\t// `options`:\n\t//  {\n\t//    country:\n\t//    {\n\t//      restrict - (a two-letter country code)\n\t//                 the phone number must be in this country\n\t//\n\t//      default - (a two-letter country code)\n\t//                default country to use for phone number parsing and validation\n\t//                (if no country code could be derived from the phone number)\n\t//    }\n\t//  }\n\t//\n\t// Returns `{ country, number }`\n\t//\n\t// Example use cases:\n\t//\n\t// ```js\n\t// parse('8 (800) 555-35-35', 'RU')\n\t// parse('8 (800) 555-35-35', 'RU', metadata)\n\t// parse('8 (800) 555-35-35', { country: { default: 'RU' } })\n\t// parse('8 (800) 555-35-35', { country: { default: 'RU' } }, metadata)\n\t// parse('+7 800 555 35 35')\n\t// parse('+7 800 555 35 35', metadata)\n\t// ```\n\t//\n};export default function parse(arg_1, arg_2, arg_3) {\n\tvar _sort_out_arguments = sort_out_arguments(arg_1, arg_2, arg_3),\n\t    text = _sort_out_arguments.text,\n\t    options = _sort_out_arguments.options,\n\t    metadata = _sort_out_arguments.metadata;\n\n\t// Validate country codes\n\n\t// Validate `default` country\n\n\n\tif (options.country.default && !metadata.countries[options.country.default]) {\n\t\tthrow new Error('Unknown country code: ' + options.country.default);\n\t}\n\n\t// Validate `restrict` country\n\tif (options.country.restrict && !metadata.countries[options.country.restrict]) {\n\t\tthrow new Error('Unknown country code: ' + options.country.restrict);\n\t}\n\n\t// Parse the phone number\n\n\tvar formatted_phone_number = void 0;\n\tvar extension = void 0;\n\n\t// Parse RFC 3966 phone number URI.\n\tif (text && text.indexOf('tel:') === 0) {\n\t\tvar _iteratorNormalCompletion = true;\n\t\tvar _didIteratorError = false;\n\t\tvar _iteratorError = undefined;\n\n\t\ttry {\n\t\t\tfor (var _iterator = _getIterator(text.split(';')), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\t\tvar part = _step.value;\n\n\t\t\t\tvar _part$split = part.split(':'),\n\t\t\t\t    _part$split2 = _slicedToArray(_part$split, 2),\n\t\t\t\t    name = _part$split2[0],\n\t\t\t\t    value = _part$split2[1];\n\n\t\t\t\tswitch (name) {\n\t\t\t\t\tcase 'tel':\n\t\t\t\t\t\tformatted_phone_number = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'ext':\n\t\t\t\t\t\textension = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'phone-context':\n\t\t\t\t\t\t// Domain contexts are ignored.\n\t\t\t\t\t\tif (value[0] === '+') {\n\t\t\t\t\t\t\tformatted_phone_number = value + formatted_phone_number;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t_didIteratorError = true;\n\t\t\t_iteratorError = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t\t_iterator.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError) {\n\t\t\t\t\tthrow _iteratorError;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tformatted_phone_number = extract_formatted_phone_number(text);\n\t}\n\n\t// If the phone number is not viable, then abort.\n\tif (!is_viable_phone_number(formatted_phone_number)) {\n\t\treturn {};\n\t}\n\n\t// Attempt to parse extension first, since it doesn't require region-specific\n\t// data and we want to have the non-normalised number here.\n\tvar with_extension_stripped = strip_extension(formatted_phone_number);\n\n\tif (with_extension_stripped.extension) {\n\t\tformatted_phone_number = with_extension_stripped.number, extension = with_extension_stripped.extension;\n\t}\n\n\tvar _parse_phone_number_a = parse_phone_number_and_country_phone_code(formatted_phone_number, metadata),\n\t    country_phone_code = _parse_phone_number_a.country_phone_code,\n\t    number = _parse_phone_number_a.number;\n\n\t// Maybe invalid country phone code encountered\n\n\n\tif (!number) {\n\t\treturn {};\n\t}\n\n\tvar country = void 0;\n\tvar country_metadata = void 0;\n\n\t// Whether the phone number is formatted as an international phone number\n\tvar is_international = false;\n\n\tif (country_phone_code) {\n\t\tis_international = true;\n\n\t\t// Check country restriction\n\t\tif (options.country.restrict && country_phone_code !== get_phone_code(metadata.countries[options.country.restrict])) {\n\t\t\treturn {};\n\t\t}\n\n\t\t// Formatting information for regions which share\n\t\t// a country calling code is contained by only one region\n\t\t// for performance reasons. For example, for NANPA region\n\t\t// (\"North American Numbering Plan Administration\",\n\t\t//  which includes USA, Canada, Cayman Islands, Bahamas, etc)\n\t\t// it will be contained in the metadata for `US`.\n\t\tcountry_metadata = get_metadata_by_country_phone_code(country_phone_code, metadata);\n\n\t\t// `country` will be set later,\n\t\t// because, for example, for NANPA countries\n\t\t// there are several countries corresponding\n\t\t// to the same `1` country phone code.\n\t\t// Therefore, to reliably determine the exact country,\n\t\t// national (significant) number should be parsed first.\n\t} else if (options.country.restrict || options.country.default) {\n\t\tcountry = options.country.restrict || options.country.default;\n\t\tcountry_metadata = metadata.countries[country];\n\n\t\tnumber = normalize(formatted_phone_number);\n\t}\n\n\tif (!country_metadata) {\n\t\treturn {};\n\t}\n\n\tvar national_number = number;\n\n\t// Only strip national prefixes for non-international phone numbers\n\t// because national prefixes can't be present in international phone numbers.\n\t// Otherwise, while forgiving, it would parse a NANPA number `+1 1877 215 5230`\n\t// first to `1877 215 5230` and then, stripping the leading `1`, to `877 215 5230`,\n\t// and then it would assume that's a valid number which it isn't.\n\t// So no forgiveness for grandmas here.\n\t// The issue asking for this fix:\n\t// https://github.com/catamphetamine/libphonenumber-js/issues/159\n\tif (!is_international) {\n\t\tnational_number = strip_national_prefix(number, country_metadata);\n\t}\n\n\tvar did_have_national_prefix = national_number !== number;\n\n\t// https://github.com/catamphetamine/libphonenumber-js/issues/67\n\t// if (!is_international && !did_have_national_prefix &&\n\t// \t\tis_national_prefix_required(national_number, country_metadata))\n\t// {\n\t// \treturn {}\n\t// }\n\n\t// Sometimes there are several countries\n\t// corresponding to the same country phone code\n\t// (e.g. NANPA countries all having `1` country phone code).\n\t// Therefore, to reliably determine the exact country,\n\t// national (significant) number should have been parsed first.\n\t//\n\tif (!country) {\n\t\t// When `metadata.json` is generated, all \"ambiguous\" country phone codes\n\t\t// get their countries populated with the full set of\n\t\t// \"phone number type\" regular expressions.\n\t\tcountry = find_country_code(country_phone_code, national_number, metadata);\n\n\t\t// Just in case there appears to be a bug in Google's metadata\n\t\t// and the exact country could not be extracted from the phone number.\n\t\t/* istanbul ignore if */\n\t\tif (!country) {\n\t\t\treturn {};\n\t\t}\n\n\t\t// Update metadata to be for this specific country\n\t\tcountry_metadata = metadata.countries[country];\n\t}\n\n\t// Validate national (significant) number length.\n\t//\n\t// A sidenote:\n\t//\n\t// They say that sometimes national (significant) numbers\n\t// can be longer than `MAX_LENGTH_FOR_NSN` (e.g. in Germany).\n\t// https://github.com/googlei18n/libphonenumber/blob/7e1748645552da39c4e1ba731e47969d97bdb539/resources/phonenumber.proto#L36\n\t// Such numbers will just be discarded.\n\t//\n\tif (national_number.length > MAX_LENGTH_FOR_NSN) {\n\t\treturn {};\n\t}\n\n\t// National number pattern is different for each country,\n\t// even for those ones which are part of the \"NANPA\" group.\n\tvar national_number_rule = new RegExp(get_national_number_pattern(country_metadata));\n\n\t// Check if national phone number pattern matches the number\n\tif (!matches_entirely(national_number, national_number_rule)) {\n\t\treturn {};\n\t}\n\n\tvar result = {\n\t\tcountry: country,\n\t\tphone: national_number\n\t};\n\n\tif (extension) {\n\t\tresult.ext = extension;\n\t}\n\n\treturn result;\n}\n\n// Normalizes a string of characters representing a phone number.\n// This converts wide-ascii and arabic-indic numerals to European numerals,\n// and strips punctuation and alpha characters.\n//\n// E.g. in Iraq they don't write `+442323234` but rather `+٤٤٢٣٢٣٢٣٤`.\n//\nexport function normalize(number) {\n\treturn replace_characters(number, DIGIT_MAPPINGS);\n}\n\n// For any character not being part of `replacements`\n// it is removed from the phone number.\nexport function replace_characters(text, replacements) {\n\tvar replaced = '';\n\n\tvar _iteratorNormalCompletion2 = true;\n\tvar _didIteratorError2 = false;\n\tvar _iteratorError2 = undefined;\n\n\ttry {\n\t\tfor (var _iterator2 = _getIterator(text), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t\t\tvar character = _step2.value;\n\n\t\t\tvar replacement = replacements[character.toUpperCase()];\n\n\t\t\tif (replacement !== undefined) {\n\t\t\t\treplaced += replacement;\n\t\t\t}\n\t\t}\n\t} catch (err) {\n\t\t_didIteratorError2 = true;\n\t\t_iteratorError2 = err;\n\t} finally {\n\t\ttry {\n\t\t\tif (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t\t\t\t_iterator2.return();\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_didIteratorError2) {\n\t\t\t\tthrow _iteratorError2;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn replaced;\n}\n\n// Checks to see if the string of characters could possibly be a phone number at\n// all. At the moment, checks to see that the string begins with at least 2\n// digits, ignoring any punctuation commonly found in phone numbers. This method\n// does not require the number to be normalized in advance - but does assume\n// that leading non-number symbols have been removed, such as by the method\n// `extract_possible_number`.\n//\nexport function is_viable_phone_number(number) {\n\treturn number.length >= MIN_LENGTH_FOR_NSN && matches_entirely(number, VALID_PHONE_NUMBER_PATTERN);\n}\n\nexport function extract_formatted_phone_number(text) {\n\tif (!text || text.length > MAX_INPUT_STRING_LENGTH) {\n\t\treturn '';\n\t}\n\n\t// Attempt to extract a possible number from the string passed in\n\n\tvar starts_at = text.search(PHONE_NUMBER_START_PATTERN);\n\n\tif (starts_at < 0) {\n\t\treturn '';\n\t}\n\n\treturn text\n\t// Trim everything to the left of the phone number\n\t.slice(starts_at)\n\t// Remove trailing non-numerical characters\n\t.replace(AFTER_PHONE_NUMBER_END_PATTERN, '');\n}\n\n// Parses a formatted phone number.\nexport function parse_phone_number(number) {\n\tif (!number) {\n\t\treturn '';\n\t}\n\n\tvar is_international = LEADING_PLUS_CHARS_PATTERN.test(number);\n\n\t// Remove non-digits\n\t// (and strip the possible leading '+')\n\tnumber = normalize(number);\n\n\tif (is_international) {\n\t\treturn '+' + number;\n\t}\n\n\treturn number;\n}\n\n// Parses a formatted phone number\n// and returns `{ country_phone_code, number }`\n// where `number` is the national (significant) phone number.\n//\n// (aka `maybeExtractCountryPhoneCode`)\n//\nexport function parse_phone_number_and_country_phone_code(number, metadata) {\n\tnumber = parse_phone_number(number);\n\n\tif (!number) {\n\t\treturn {};\n\t}\n\n\t// If this is not an international phone number,\n\t// then don't extract country phone code.\n\tif (number[0] !== '+') {\n\t\treturn { number: number };\n\t}\n\n\t// Strip the leading '+' sign\n\tnumber = number.slice(1);\n\n\t// Fast abortion: country codes do not begin with a '0'\n\tif (number[0] === '0') {\n\t\treturn {};\n\t}\n\n\t// The thing with country phone codes\n\t// is that they are orthogonal to each other\n\t// i.e. there's no such country phone code A\n\t// for which country phone code B exists\n\t// where B starts with A.\n\t// Therefore, while scanning digits,\n\t// if a valid country code is found,\n\t// that means that it is the country code.\n\t//\n\tvar i = 1;\n\twhile (i <= MAX_LENGTH_COUNTRY_CODE && i <= number.length) {\n\t\tvar country_phone_code = number.slice(0, i);\n\n\t\tif (metadata.country_phone_code_to_countries[country_phone_code]) {\n\t\t\treturn { country_phone_code: country_phone_code, number: number.slice(i) };\n\t\t}\n\n\t\ti++;\n\t}\n\n\treturn {};\n}\n\n// Strips any national prefix (such as 0, 1) present in the number provided\nexport function strip_national_prefix(number, country_metadata) {\n\tvar national_prefix_for_parsing = get_national_prefix_for_parsing(country_metadata);\n\n\tif (!number || !national_prefix_for_parsing) {\n\t\treturn number;\n\t}\n\n\t// Attempt to parse the first digits as a national prefix\n\tvar national_prefix_pattern = new RegExp('^(?:' + national_prefix_for_parsing + ')');\n\tvar national_prefix_matcher = national_prefix_pattern.exec(number);\n\n\t// If no national prefix is present in the phone number,\n\t// but if the national prefix is optional for this country,\n\t// then consider this phone number valid.\n\t//\n\t// Google's reference `libphonenumber` implementation\n\t// wouldn't recognize such phone numbers as valid,\n\t// but I think it would perfectly make sense\n\t// to consider such phone numbers as valid\n\t// because if a national phone number was originally\n\t// formatted without the national prefix\n\t// then it must be parseable back into the original national number.\n\t// In other words, `parse(format(number))`\n\t// must always be equal to `number`.\n\t//\n\tif (!national_prefix_matcher) {\n\t\treturn number;\n\t}\n\n\tvar national_significant_number = void 0;\n\n\t// `national_prefix_for_parsing` capturing groups\n\t// (used only for really messy cases: Argentina, Brazil, Mexico, Somalia)\n\tvar any_groups_were_captured = national_prefix_matcher[national_prefix_matcher.length - 1];\n\tvar national_prefix_transform_rule = get_national_prefix_transform_rule(country_metadata);\n\n\t// If the national number tranformation is needed then do it\n\tif (national_prefix_transform_rule && any_groups_were_captured) {\n\t\tnational_significant_number = number.replace(national_prefix_pattern, national_prefix_transform_rule);\n\t}\n\t// Else, no transformation is necessary,\n\t// and just strip the national prefix.\n\telse {\n\t\t\tnational_significant_number = number.slice(national_prefix_matcher[0].length);\n\t\t}\n\n\t// Verify the parsed national (significant) number for this country\n\tvar national_number_rule = new RegExp(get_national_number_pattern(country_metadata));\n\n\t// If the original number (before stripping national prefix) was viable,\n\t// and the resultant number is not, then prefer the original phone number.\n\t// This is because for some countries (e.g. Russia) the same digit could be both\n\t// a national prefix and a leading digit of a valid national phone number,\n\t// like `8` is the national prefix for Russia and both\n\t// `8 800 555 35 35` and `800 555 35 35` are valid numbers.\n\tif (matches_entirely(number, national_number_rule) && !matches_entirely(national_significant_number, national_number_rule)) {\n\t\treturn number;\n\t}\n\n\t// Return the parsed national (significant) number\n\treturn national_significant_number;\n}\n\nexport function find_country_code(country_phone_code, national_phone_number, metadata) {\n\t// Is always non-empty, because `country_phone_code` is always valid\n\tvar possible_countries = metadata.country_phone_code_to_countries[country_phone_code];\n\n\t// If there's just one country corresponding to the country code,\n\t// then just return it, without further phone number digits validation.\n\tif (possible_countries.length === 1) {\n\t\treturn possible_countries[0];\n\t}\n\n\tvar _iteratorNormalCompletion3 = true;\n\tvar _didIteratorError3 = false;\n\tvar _iteratorError3 = undefined;\n\n\ttry {\n\t\tfor (var _iterator3 = _getIterator(possible_countries), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t\t\tvar country_code = _step3.value;\n\n\t\t\tvar country = metadata.countries[country_code];\n\n\t\t\t// Leading digits check would be the simplest one\n\t\t\tif (get_leading_digits(country)) {\n\t\t\t\tif (national_phone_number && national_phone_number.search(get_leading_digits(country)) === 0) {\n\t\t\t\t\treturn country_code;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Else perform full validation with all of those bulky\n\t\t\t// fixed-line/mobile/etc regular expressions.\n\t\t\telse if (get_number_type({ phone: national_phone_number, country: country_code }, metadata)) {\n\t\t\t\t\treturn country_code;\n\t\t\t\t}\n\t\t}\n\t} catch (err) {\n\t\t_didIteratorError3 = true;\n\t\t_iteratorError3 = err;\n\t} finally {\n\t\ttry {\n\t\t\tif (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t\t\t\t_iterator3.return();\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_didIteratorError3) {\n\t\t\t\tthrow _iteratorError3;\n\t\t\t}\n\t\t}\n\t}\n}\n\n// export function is_national_prefix_required(national_number, country_metadata)\n// {\n// \tconst format = choose_format_for_number(get_formats(country_metadata), national_number)\n//\n// \tif (format)\n// \t{\n// \t\treturn get_format_national_prefix_is_mandatory_when_formatting(format, country_metadata)\n// \t}\n// }\n\n// Sort out arguments\nfunction sort_out_arguments(arg_1, arg_2, arg_3) {\n\tvar text = void 0;\n\tvar options = void 0;\n\tvar metadata = void 0;\n\n\t// Normalize numerical `value`.\n\t// https://github.com/catamphetamine/libphonenumber-js/issues/142\n\t// `parse(88005553535, ...)`.\n\tif (typeof arg_1 === 'number') {\n\t\targ_1 = String(arg_1);\n\t}\n\n\t// If the phone number is passed as a string.\n\t// `parse('88005553535', ...)`.\n\tif (typeof arg_1 === 'string') {\n\t\ttext = arg_1;\n\t}\n\n\t// If \"resrict country\" argument is being passed\n\t// then convert it to an `options` object.\n\t// `parse('88005553535', 'RU', [options], metadata)`.\n\tif (typeof arg_2 === 'string') {\n\t\toptions = { country: { restrict: arg_2 } };\n\t\tmetadata = arg_3;\n\t}\n\t// No \"resrict country\" argument is being passed.\n\t// International phone number is passed.\n\t// `parse('+78005553535', [options], metadata)`.\n\telse {\n\t\t\tif (arg_3) {\n\t\t\t\toptions = arg_2;\n\t\t\t\tmetadata = arg_3;\n\t\t\t} else {\n\t\t\t\tmetadata = arg_2;\n\t\t\t}\n\t\t}\n\n\t// Metadata is required.\n\tif (!metadata || !metadata.countries) {\n\t\tthrow new Error('Metadata is required');\n\t}\n\n\t// Apply default options.\n\tif (options) {\n\t\toptions = _extends({}, default_options, options);\n\t} else {\n\t\toptions = default_options;\n\t}\n\n\treturn { text: text, options: options, metadata: metadata };\n}\n\n// Strips any extension (as in, the part of the number dialled after the call is\n// connected, usually indicated with extn, ext, x or similar) from the end of\n// the number, and returns it.\nfunction strip_extension(number) {\n\tvar start = number.search(EXTN_PATTERN);\n\tif (start < 0) {\n\t\treturn {};\n\t}\n\n\t// If we find a potential extension, and the number preceding this is a viable\n\t// number, we assume it is an extension.\n\tvar number_without_extension = number.slice(0, start);\n\t/* istanbul ignore if - seems a bit of a redundant check */\n\tif (!is_viable_phone_number(number_without_extension)) {\n\t\treturn {};\n\t}\n\n\tvar matches = number.match(EXTN_PATTERN);\n\tvar i = 1;\n\twhile (i < matches.length) {\n\t\tif (matches[i] != null && matches[i].length > 0) {\n\t\t\treturn {\n\t\t\t\tnumber: number_without_extension,\n\t\t\t\textension: matches[i]\n\t\t\t};\n\t\t}\n\t\ti++;\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import parse, { is_viable_phone_number } from './parse';\nimport { matches_entirely } from './common';\nimport { get_national_number_pattern, get_type_fixed_line, get_type_mobile, get_type_toll_free, get_type_premium_rate, get_type_personal_number, get_type_voice_mail, get_type_uan, get_type_pager, get_type_voip, get_type_shared_cost } from './metadata'; // Finds out national phone number type (fixed line, mobile, etc)\n\nexport default function get_number_type(arg_1, arg_2, arg_3) {\n  var _sort_out_arguments = sort_out_arguments(arg_1, arg_2, arg_3),\n      input = _sort_out_arguments.input,\n      metadata = _sort_out_arguments.metadata; // When no input was passed\n\n\n  if (!input) {\n    return;\n  } // When `parse()` returned `{}`\n  // meaning that the phone number is not a valid one.\n\n\n  if (!input.country) {\n    return;\n  }\n\n  var national_number = input.phone;\n  var country_metadata = metadata.countries[input.country]; // The following is copy-pasted from the original function:\n  // https://github.com/googlei18n/libphonenumber/blob/3ea547d4fbaa2d0b67588904dfa5d3f2557c27ff/javascript/i18n/phonenumbers/phonenumberutil.js#L2835\n  // Is this national number even valid for this country\n\n  if (!is_of_type(national_number, get_national_number_pattern(country_metadata))) {\n    return; // 'UNKNOWN'\n  }\n\n  if (is_of_type(national_number, get_type_premium_rate(country_metadata))) {\n    return 'PREMIUM_RATE';\n  }\n\n  if (is_of_type(national_number, get_type_toll_free(country_metadata))) {\n    return 'TOLL_FREE';\n  }\n  /* istanbul ignore if */\n\n\n  if (is_of_type(national_number, get_type_shared_cost(country_metadata))) {\n    return 'SHARED_COST';\n  }\n  /* istanbul ignore if */\n\n\n  if (is_of_type(national_number, get_type_voip(country_metadata))) {\n    return 'VOIP';\n  }\n\n  if (is_of_type(national_number, get_type_personal_number(country_metadata))) {\n    return 'PERSONAL_NUMBER';\n  }\n  /* istanbul ignore if */\n\n\n  if (is_of_type(national_number, get_type_pager(country_metadata))) {\n    return 'PAGER';\n  }\n  /* istanbul ignore if */\n\n\n  if (is_of_type(national_number, get_type_uan(country_metadata))) {\n    return 'UAN';\n  }\n  /* istanbul ignore if */\n\n\n  if (is_of_type(national_number, get_type_voice_mail(country_metadata))) {\n    return 'VOICEMAIL';\n  } // Is it fixed line number\n\n\n  if (is_of_type(national_number, get_type_fixed_line(country_metadata))) {\n    // Because duplicate regular expressions are removed\n    // to reduce metadata size, if there's no \"mobile\" pattern\n    // then it means it was removed due to being a duplicate of some other pattern.\n    //\n    if (!get_type_mobile(country_metadata)) {\n      return 'FIXED_LINE_OR_MOBILE';\n    } // Check if the number happens to qualify as both fixed line and mobile.\n    // (no such country in the minimal metadata set)\n\n    /* istanbul ignore if */\n\n\n    if (is_of_type(national_number, get_type_mobile(country_metadata))) {\n      return 'FIXED_LINE_OR_MOBILE';\n    }\n\n    return 'FIXED_LINE';\n  }\n\n  if (is_of_type(national_number, get_type_mobile(country_metadata))) {\n    return 'MOBILE';\n  } // return 'UNKNOWN'\n\n}\nexport function is_of_type(national_number, type) {\n  // // Check if any possible number lengths are present;\n  // // if so, we use them to avoid checking\n  // // the validation pattern if they don't match.\n  // // If they are absent, this means they match\n  // // the general description, which we have\n  // // already checked before a specific number type.\n  // if (get_possible_lengths(type) &&\n  // \tget_possible_lengths(type).indexOf(national_number.length) === -1)\n  // {\n  // \treturn false\n  // }\n  // get_type_pattern(type) === type\n  return matches_entirely(national_number, type);\n} // Sort out arguments\n\nexport function sort_out_arguments(arg_1, arg_2, arg_3) {\n  var input = void 0;\n  var metadata = void 0; // Normalize numerical `value`.\n  // https://github.com/catamphetamine/libphonenumber-js/issues/142\n  // `getNumberType(88005553535, ...)`.\n\n  if (typeof arg_1 === 'number') {\n    arg_1 = String(arg_1);\n  } // If the phone number is passed as a string.\n  // `getNumberType('88005553535', ...)`.\n\n\n  if (typeof arg_1 === 'string') {\n    // If \"resrict country\" argument is being passed\n    // then convert it to an `options` object.\n    // `getNumberType('88005553535', 'RU', metadata)`.\n    if (typeof arg_2 === 'string' || arg_2 === undefined) {\n      metadata = arg_3; // `parse` extracts phone numbers from raw text,\n      // therefore it will cut off all \"garbage\" characters,\n      // while this `validate` function needs to verify\n      // that the phone number contains no \"garbage\"\n      // therefore the explicit `is_viable_phone_number` check.\n\n      if (is_viable_phone_number(arg_1)) {\n        input = parse(arg_1, arg_2, metadata);\n      }\n    } // No \"resrict country\" argument is being passed.\n    // International phone number is passed.\n    // `getNumberType('+78005553535', metadata)`.\n    else {\n      metadata = arg_2; // `parse` extracts phone numbers from raw text,\n      // therefore it will cut off all \"garbage\" characters,\n      // while this `validate` function needs to verify\n      // that the phone number contains no \"garbage\"\n      // therefore the explicit `is_viable_phone_number` check.\n\n      if (is_viable_phone_number(arg_1)) {\n        input = parse(arg_1, metadata);\n      }\n    }\n  } // If the phone number is passed as a parsed phone number.\n  // `getNumberType({ phone: '88005553535', country: 'RU' }, ...)`.\n  else {\n    // The `arg_1` must be a valid phone number\n    // as a whole, not just a part of it which gets parsed here.\n    if (arg_1 && arg_1.phone && is_viable_phone_number(arg_1.phone)) {\n      input = arg_1;\n    }\n\n    metadata = arg_2;\n  } // Metadata is required.\n\n\n  if (!metadata || !metadata.countries) {\n    throw new Error('Metadata is required');\n  }\n\n  return {\n    input: input,\n    metadata: metadata\n  };\n}","map":{"version":3,"names":["parse","is_viable_phone_number","matches_entirely","get_national_number_pattern","get_type_fixed_line","get_type_mobile","get_type_toll_free","get_type_premium_rate","get_type_personal_number","get_type_voice_mail","get_type_uan","get_type_pager","get_type_voip","get_type_shared_cost","get_number_type","arg_1","arg_2","arg_3","_sort_out_arguments","sort_out_arguments","input","metadata","country","national_number","phone","country_metadata","countries","is_of_type","type","String","undefined","Error"],"sources":["/usr/src/app/node_modules/libphonenumber-js/es6/types.js"],"sourcesContent":["import parse, { is_viable_phone_number } from './parse';\n\nimport { matches_entirely } from './common';\n\nimport { get_national_number_pattern, get_type_fixed_line, get_type_mobile, get_type_toll_free, get_type_premium_rate, get_type_personal_number, get_type_voice_mail, get_type_uan, get_type_pager, get_type_voip, get_type_shared_cost } from './metadata';\n\n// Finds out national phone number type (fixed line, mobile, etc)\nexport default function get_number_type(arg_1, arg_2, arg_3) {\n\tvar _sort_out_arguments = sort_out_arguments(arg_1, arg_2, arg_3),\n\t    input = _sort_out_arguments.input,\n\t    metadata = _sort_out_arguments.metadata;\n\n\t// When no input was passed\n\n\n\tif (!input) {\n\t\treturn;\n\t}\n\n\t// When `parse()` returned `{}`\n\t// meaning that the phone number is not a valid one.\n\tif (!input.country) {\n\t\treturn;\n\t}\n\n\tvar national_number = input.phone;\n\tvar country_metadata = metadata.countries[input.country];\n\n\t// The following is copy-pasted from the original function:\n\t// https://github.com/googlei18n/libphonenumber/blob/3ea547d4fbaa2d0b67588904dfa5d3f2557c27ff/javascript/i18n/phonenumbers/phonenumberutil.js#L2835\n\n\t// Is this national number even valid for this country\n\tif (!is_of_type(national_number, get_national_number_pattern(country_metadata))) {\n\t\treturn; // 'UNKNOWN'\n\t}\n\n\tif (is_of_type(national_number, get_type_premium_rate(country_metadata))) {\n\t\treturn 'PREMIUM_RATE';\n\t}\n\n\tif (is_of_type(national_number, get_type_toll_free(country_metadata))) {\n\t\treturn 'TOLL_FREE';\n\t}\n\n\t/* istanbul ignore if */\n\tif (is_of_type(national_number, get_type_shared_cost(country_metadata))) {\n\t\treturn 'SHARED_COST';\n\t}\n\n\t/* istanbul ignore if */\n\tif (is_of_type(national_number, get_type_voip(country_metadata))) {\n\t\treturn 'VOIP';\n\t}\n\n\tif (is_of_type(national_number, get_type_personal_number(country_metadata))) {\n\t\treturn 'PERSONAL_NUMBER';\n\t}\n\n\t/* istanbul ignore if */\n\tif (is_of_type(national_number, get_type_pager(country_metadata))) {\n\t\treturn 'PAGER';\n\t}\n\n\t/* istanbul ignore if */\n\tif (is_of_type(national_number, get_type_uan(country_metadata))) {\n\t\treturn 'UAN';\n\t}\n\n\t/* istanbul ignore if */\n\tif (is_of_type(national_number, get_type_voice_mail(country_metadata))) {\n\t\treturn 'VOICEMAIL';\n\t}\n\n\t// Is it fixed line number\n\tif (is_of_type(national_number, get_type_fixed_line(country_metadata))) {\n\t\t// Because duplicate regular expressions are removed\n\t\t// to reduce metadata size, if there's no \"mobile\" pattern\n\t\t// then it means it was removed due to being a duplicate of some other pattern.\n\t\t//\n\t\tif (!get_type_mobile(country_metadata)) {\n\t\t\treturn 'FIXED_LINE_OR_MOBILE';\n\t\t}\n\n\t\t// Check if the number happens to qualify as both fixed line and mobile.\n\t\t// (no such country in the minimal metadata set)\n\t\t/* istanbul ignore if */\n\t\tif (is_of_type(national_number, get_type_mobile(country_metadata))) {\n\t\t\treturn 'FIXED_LINE_OR_MOBILE';\n\t\t}\n\n\t\treturn 'FIXED_LINE';\n\t}\n\n\tif (is_of_type(national_number, get_type_mobile(country_metadata))) {\n\t\treturn 'MOBILE';\n\t}\n\n\t// return 'UNKNOWN'\n}\n\nexport function is_of_type(national_number, type) {\n\t// // Check if any possible number lengths are present;\n\t// // if so, we use them to avoid checking\n\t// // the validation pattern if they don't match.\n\t// // If they are absent, this means they match\n\t// // the general description, which we have\n\t// // already checked before a specific number type.\n\t// if (get_possible_lengths(type) &&\n\t// \tget_possible_lengths(type).indexOf(national_number.length) === -1)\n\t// {\n\t// \treturn false\n\t// }\n\n\t// get_type_pattern(type) === type\n\treturn matches_entirely(national_number, type);\n}\n\n// Sort out arguments\nexport function sort_out_arguments(arg_1, arg_2, arg_3) {\n\tvar input = void 0;\n\tvar metadata = void 0;\n\n\t// Normalize numerical `value`.\n\t// https://github.com/catamphetamine/libphonenumber-js/issues/142\n\t// `getNumberType(88005553535, ...)`.\n\tif (typeof arg_1 === 'number') {\n\t\targ_1 = String(arg_1);\n\t}\n\n\t// If the phone number is passed as a string.\n\t// `getNumberType('88005553535', ...)`.\n\tif (typeof arg_1 === 'string') {\n\t\t// If \"resrict country\" argument is being passed\n\t\t// then convert it to an `options` object.\n\t\t// `getNumberType('88005553535', 'RU', metadata)`.\n\t\tif (typeof arg_2 === 'string' || arg_2 === undefined) {\n\t\t\tmetadata = arg_3;\n\n\t\t\t// `parse` extracts phone numbers from raw text,\n\t\t\t// therefore it will cut off all \"garbage\" characters,\n\t\t\t// while this `validate` function needs to verify\n\t\t\t// that the phone number contains no \"garbage\"\n\t\t\t// therefore the explicit `is_viable_phone_number` check.\n\t\t\tif (is_viable_phone_number(arg_1)) {\n\t\t\t\tinput = parse(arg_1, arg_2, metadata);\n\t\t\t}\n\t\t}\n\t\t// No \"resrict country\" argument is being passed.\n\t\t// International phone number is passed.\n\t\t// `getNumberType('+78005553535', metadata)`.\n\t\telse {\n\t\t\t\tmetadata = arg_2;\n\n\t\t\t\t// `parse` extracts phone numbers from raw text,\n\t\t\t\t// therefore it will cut off all \"garbage\" characters,\n\t\t\t\t// while this `validate` function needs to verify\n\t\t\t\t// that the phone number contains no \"garbage\"\n\t\t\t\t// therefore the explicit `is_viable_phone_number` check.\n\t\t\t\tif (is_viable_phone_number(arg_1)) {\n\t\t\t\t\tinput = parse(arg_1, metadata);\n\t\t\t\t}\n\t\t\t}\n\t}\n\t// If the phone number is passed as a parsed phone number.\n\t// `getNumberType({ phone: '88005553535', country: 'RU' }, ...)`.\n\telse {\n\t\t\t// The `arg_1` must be a valid phone number\n\t\t\t// as a whole, not just a part of it which gets parsed here.\n\t\t\tif (arg_1 && arg_1.phone && is_viable_phone_number(arg_1.phone)) {\n\t\t\t\tinput = arg_1;\n\t\t\t}\n\n\t\t\tmetadata = arg_2;\n\t\t}\n\n\t// Metadata is required.\n\tif (!metadata || !metadata.countries) {\n\t\tthrow new Error('Metadata is required');\n\t}\n\n\treturn { input: input, metadata: metadata };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}
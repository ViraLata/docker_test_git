{"ast":null,"code":"import _extends from 'babel-runtime/helpers/extends';\nimport _getIterator from 'babel-runtime/core-js/get-iterator'; // This is a port of Google Android `libphonenumber`'s\n// `phonenumberutil.js` of 17th November, 2016.\n//\n// https://github.com/googlei18n/libphonenumber/commits/master/javascript/i18n/phonenumbers/phonenumberutil.js\n\nimport { matches_entirely } from './common';\nimport { parse_phone_number_and_country_phone_code, VALID_PUNCTUATION } from './parse';\nimport { get_phone_code, get_formats, get_format_pattern, get_format_format, get_format_leading_digits_patterns, get_format_national_prefix_formatting_rule, get_format_national_prefix_is_optional_when_formatting, get_format_international_format, get_metadata_by_country_phone_code } from './metadata';\nvar default_options = {\n  formatExtension: function formatExtension(number, extension) {\n    return number + ' ext. ' + extension;\n  } // Formats a phone number\n  //\n  // Example use cases:\n  //\n  // ```js\n  // format('8005553535', 'RU', 'International')\n  // format('8005553535', 'RU', 'International', metadata)\n  // format({ phone: '8005553535', country: 'RU' }, 'International')\n  // format({ phone: '8005553535', country: 'RU' }, 'International', metadata)\n  // format('+78005553535', 'National')\n  // format('+78005553535', 'National', metadata)\n  // ```\n  //\n\n};\nexport default function format(arg_1, arg_2, arg_3, arg_4, arg_5) {\n  var _sort_out_arguments = sort_out_arguments(arg_1, arg_2, arg_3, arg_4, arg_5),\n      input = _sort_out_arguments.input,\n      format_type = _sort_out_arguments.format_type,\n      options = _sort_out_arguments.options,\n      metadata = _sort_out_arguments.metadata;\n\n  var country_metadata = void 0;\n\n  if (input.country) {\n    country_metadata = metadata.countries[input.country];\n  }\n\n  var _parse_phone_number_a = parse_phone_number_and_country_phone_code(input.phone, metadata),\n      country_phone_code = _parse_phone_number_a.country_phone_code,\n      number = _parse_phone_number_a.number;\n\n  if (country_phone_code) {\n    // Check country restriction\n    if (input.country && country_metadata && country_phone_code !== get_phone_code(country_metadata)) {\n      return input.phone;\n    }\n\n    country_metadata = get_metadata_by_country_phone_code(country_phone_code, metadata);\n  }\n\n  if (!country_metadata) {\n    return input.phone;\n  }\n\n  switch (format_type) {\n    case 'International':\n      if (!number) {\n        return '+' + get_phone_code(country_metadata);\n      }\n\n      var national_number = format_national_number(number, 'International', false, country_metadata);\n      var international_number = '+' + get_phone_code(country_metadata) + ' ' + national_number;\n\n      if (input.ext || input.ext === 0) {\n        return options.formatExtension(international_number, input.ext);\n      }\n\n      return international_number;\n\n    case 'E.164': // \"International_plaintext\" is deprecated\n\n    case 'International_plaintext':\n      // `E.164` doesn't define \"phone number extensions\".\n      return '+' + get_phone_code(country_metadata) + input.phone;\n\n    case 'RFC3966':\n      return '+' + get_phone_code(country_metadata) + input.phone + (input.ext || input.ext === 0 ? ';ext=' + input.ext : '');\n\n    case 'National':\n      if (!number) {\n        return '';\n      }\n\n      var _national_number = format_national_number(number, 'National', false, country_metadata);\n\n      if (input.ext || input.ext === 0) {\n        return options.formatExtension(_national_number, input.ext);\n      }\n\n      return _national_number;\n  }\n} // This was originally set to $1 but there are some countries for which the\n// first group is not used in the national pattern (e.g. Argentina) so the $1\n// group does not match correctly.  Therefore, we use \\d, so that the first\n// group actually used in the pattern will be matched.\n\nexport var FIRST_GROUP_PATTERN = /(\\$\\d)/;\nexport function format_national_number_using_format(number, format, international, enforce_national_prefix, country_metadata) {\n  var format_pattern_matcher = new RegExp(get_format_pattern(format));\n  var national_prefix_formatting_rule = get_format_national_prefix_formatting_rule(format, country_metadata); // National prefix is omitted if there's no national prefix formatting rule\n  // set for this country, or when this rule is set but\n  // national prefix is optional for this phone number format\n  // (and it is not enforced explicitly)\n\n  var national_prefix_may_be_omitted = !national_prefix_formatting_rule || national_prefix_formatting_rule && get_format_national_prefix_is_optional_when_formatting(format, country_metadata) && !enforce_national_prefix;\n\n  if (!international && !national_prefix_may_be_omitted) {\n    return number.replace(format_pattern_matcher, get_format_format(format).replace(FIRST_GROUP_PATTERN, national_prefix_formatting_rule));\n  }\n\n  var formatted_number = number.replace(format_pattern_matcher, international ? get_format_international_format(format) : get_format_format(format));\n\n  if (international) {\n    return local_to_international_style(formatted_number);\n  }\n\n  return formatted_number;\n}\nexport function format_national_number(number, format_as, enforce_national_prefix, country_metadata) {\n  var format = choose_format_for_number(get_formats(country_metadata), number);\n\n  if (!format) {\n    return number;\n  }\n\n  return format_national_number_using_format(number, format, format_as === 'International', enforce_national_prefix, country_metadata);\n}\nexport function choose_format_for_number(available_formats, national_number) {\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = _getIterator(available_formats), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var _format = _step.value; // Validate leading digits\n\n      if (get_format_leading_digits_patterns(_format).length > 0) {\n        // The last leading_digits_pattern is used here, as it is the most detailed\n        var last_leading_digits_pattern = get_format_leading_digits_patterns(_format)[get_format_leading_digits_patterns(_format).length - 1]; // If leading digits don't match then move on to the next phone number format\n\n        if (national_number.search(last_leading_digits_pattern) !== 0) {\n          continue;\n        }\n      } // Check that the national number matches the phone number format regular expression\n\n\n      if (matches_entirely(national_number, new RegExp(get_format_pattern(_format)))) {\n        return _format;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n} // Removes brackets and replaces dashes with spaces.\n//\n// E.g. \"(999) 111-22-33\" -> \"999 111 22 33\"\n//\n\nexport function local_to_international_style(local) {\n  return local.replace(new RegExp('[' + VALID_PUNCTUATION + ']+', 'g'), ' ').trim();\n} // Sort out arguments\n\nfunction sort_out_arguments() {\n  var arg_1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var arg_2 = arguments[1];\n  var arg_3 = arguments[2];\n  var arg_4 = arguments[3];\n  var arg_5 = arguments[4];\n  var input = void 0;\n  var format_type = void 0;\n  var options = void 0;\n  var metadata = void 0; // Sort out arguments.\n  // If the phone number is passed as a string.\n  // `format('8005553535', ...)`.\n\n  if (typeof arg_1 === 'string') {\n    // If country code is supplied.\n    // `format('8005553535', 'RU', 'National', [options], metadata)`.\n    if (typeof arg_3 === 'string') {\n      // Will be `parse()`d later in code\n      input = {\n        phone: arg_1,\n        country: arg_2\n      };\n      format_type = arg_3;\n\n      if (arg_5) {\n        options = arg_4;\n        metadata = arg_5;\n      } else {\n        metadata = arg_4;\n      }\n    } // Just an international phone number is supplied\n    // `format('+78005553535', 'National', [options], metadata)`.\n    else {\n      // Will be `parse()`d later in code\n      input = {\n        phone: arg_1\n      };\n\n      if (typeof arg_2 !== 'string') {\n        throw new Error('Format type argument not passed for `format()`');\n      }\n\n      format_type = arg_2;\n\n      if (arg_4) {\n        options = arg_3;\n        metadata = arg_4;\n      } else {\n        metadata = arg_3;\n      }\n    }\n  } // If the phone number is passed as a parsed number object.\n  // `format({ phone: '8005553535', country: 'RU' }, 'National', [options], metadata)`.\n  else {\n    input = arg_1;\n    format_type = arg_2;\n\n    if (arg_4) {\n      options = arg_3;\n      metadata = arg_4;\n    } else {\n      metadata = arg_3;\n    }\n  } // Metadata is required.\n\n\n  if (!metadata) {\n    throw new Error('Metadata is required');\n  } // Validate `format_type`.\n\n\n  switch (format_type) {\n    case 'International':\n    case 'E.164': // \"International_plaintext\" is deprecated\n\n    case 'International_plaintext':\n    case 'National':\n    case 'RFC3966':\n      break;\n\n    default:\n      throw new Error('Unknown format type argument passed to \"format()\": \"' + format_type + '\"');\n  } // Apply default options.\n\n\n  if (options) {\n    options = _extends({}, default_options, options);\n  } else {\n    options = default_options;\n  }\n\n  return {\n    input: input,\n    format_type: format_type,\n    options: options,\n    metadata: metadata\n  };\n}","map":{"version":3,"names":["_extends","_getIterator","matches_entirely","parse_phone_number_and_country_phone_code","VALID_PUNCTUATION","get_phone_code","get_formats","get_format_pattern","get_format_format","get_format_leading_digits_patterns","get_format_national_prefix_formatting_rule","get_format_national_prefix_is_optional_when_formatting","get_format_international_format","get_metadata_by_country_phone_code","default_options","formatExtension","number","extension","format","arg_1","arg_2","arg_3","arg_4","arg_5","_sort_out_arguments","sort_out_arguments","input","format_type","options","metadata","country_metadata","country","countries","_parse_phone_number_a","phone","country_phone_code","national_number","format_national_number","international_number","ext","_national_number","FIRST_GROUP_PATTERN","format_national_number_using_format","international","enforce_national_prefix","format_pattern_matcher","RegExp","national_prefix_formatting_rule","national_prefix_may_be_omitted","replace","formatted_number","local_to_international_style","format_as","choose_format_for_number","available_formats","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","_step","next","done","_format","value","length","last_leading_digits_pattern","search","err","return","local","trim","arguments","Error"],"sources":["/usr/src/app/node_modules/libphonenumber-js/es6/format.js"],"sourcesContent":["import _extends from 'babel-runtime/helpers/extends';\nimport _getIterator from 'babel-runtime/core-js/get-iterator';\n// This is a port of Google Android `libphonenumber`'s\n// `phonenumberutil.js` of 17th November, 2016.\n//\n// https://github.com/googlei18n/libphonenumber/commits/master/javascript/i18n/phonenumbers/phonenumberutil.js\n\nimport { matches_entirely } from './common';\n\nimport { parse_phone_number_and_country_phone_code, VALID_PUNCTUATION } from './parse';\n\nimport { get_phone_code, get_formats, get_format_pattern, get_format_format, get_format_leading_digits_patterns, get_format_national_prefix_formatting_rule, get_format_national_prefix_is_optional_when_formatting, get_format_international_format, get_metadata_by_country_phone_code } from './metadata';\n\nvar default_options = {\n\tformatExtension: function formatExtension(number, extension) {\n\t\treturn number + ' ext. ' + extension;\n\t}\n\n\t// Formats a phone number\n\t//\n\t// Example use cases:\n\t//\n\t// ```js\n\t// format('8005553535', 'RU', 'International')\n\t// format('8005553535', 'RU', 'International', metadata)\n\t// format({ phone: '8005553535', country: 'RU' }, 'International')\n\t// format({ phone: '8005553535', country: 'RU' }, 'International', metadata)\n\t// format('+78005553535', 'National')\n\t// format('+78005553535', 'National', metadata)\n\t// ```\n\t//\n};export default function format(arg_1, arg_2, arg_3, arg_4, arg_5) {\n\tvar _sort_out_arguments = sort_out_arguments(arg_1, arg_2, arg_3, arg_4, arg_5),\n\t    input = _sort_out_arguments.input,\n\t    format_type = _sort_out_arguments.format_type,\n\t    options = _sort_out_arguments.options,\n\t    metadata = _sort_out_arguments.metadata;\n\n\tvar country_metadata = void 0;\n\n\tif (input.country) {\n\t\tcountry_metadata = metadata.countries[input.country];\n\t}\n\n\tvar _parse_phone_number_a = parse_phone_number_and_country_phone_code(input.phone, metadata),\n\t    country_phone_code = _parse_phone_number_a.country_phone_code,\n\t    number = _parse_phone_number_a.number;\n\n\tif (country_phone_code) {\n\t\t// Check country restriction\n\t\tif (input.country && country_metadata && country_phone_code !== get_phone_code(country_metadata)) {\n\t\t\treturn input.phone;\n\t\t}\n\n\t\tcountry_metadata = get_metadata_by_country_phone_code(country_phone_code, metadata);\n\t}\n\n\tif (!country_metadata) {\n\t\treturn input.phone;\n\t}\n\n\tswitch (format_type) {\n\t\tcase 'International':\n\t\t\tif (!number) {\n\t\t\t\treturn '+' + get_phone_code(country_metadata);\n\t\t\t}\n\t\t\tvar national_number = format_national_number(number, 'International', false, country_metadata);\n\t\t\tvar international_number = '+' + get_phone_code(country_metadata) + ' ' + national_number;\n\t\t\tif (input.ext || input.ext === 0) {\n\t\t\t\treturn options.formatExtension(international_number, input.ext);\n\t\t\t}\n\t\t\treturn international_number;\n\n\t\tcase 'E.164':\n\t\t// \"International_plaintext\" is deprecated\n\t\tcase 'International_plaintext':\n\t\t\t// `E.164` doesn't define \"phone number extensions\".\n\t\t\treturn '+' + get_phone_code(country_metadata) + input.phone;\n\n\t\tcase 'RFC3966':\n\t\t\treturn '+' + get_phone_code(country_metadata) + input.phone + (input.ext || input.ext === 0 ? ';ext=' + input.ext : '');\n\n\t\tcase 'National':\n\t\t\tif (!number) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tvar _national_number = format_national_number(number, 'National', false, country_metadata);\n\t\t\tif (input.ext || input.ext === 0) {\n\t\t\t\treturn options.formatExtension(_national_number, input.ext);\n\t\t\t}\n\t\t\treturn _national_number;\n\t}\n}\n\n// This was originally set to $1 but there are some countries for which the\n// first group is not used in the national pattern (e.g. Argentina) so the $1\n// group does not match correctly.  Therefore, we use \\d, so that the first\n// group actually used in the pattern will be matched.\nexport var FIRST_GROUP_PATTERN = /(\\$\\d)/;\n\nexport function format_national_number_using_format(number, format, international, enforce_national_prefix, country_metadata) {\n\tvar format_pattern_matcher = new RegExp(get_format_pattern(format));\n\n\tvar national_prefix_formatting_rule = get_format_national_prefix_formatting_rule(format, country_metadata);\n\n\t// National prefix is omitted if there's no national prefix formatting rule\n\t// set for this country, or when this rule is set but\n\t// national prefix is optional for this phone number format\n\t// (and it is not enforced explicitly)\n\tvar national_prefix_may_be_omitted = !national_prefix_formatting_rule || national_prefix_formatting_rule && get_format_national_prefix_is_optional_when_formatting(format, country_metadata) && !enforce_national_prefix;\n\n\tif (!international && !national_prefix_may_be_omitted) {\n\t\treturn number.replace(format_pattern_matcher, get_format_format(format).replace(FIRST_GROUP_PATTERN, national_prefix_formatting_rule));\n\t}\n\n\tvar formatted_number = number.replace(format_pattern_matcher, international ? get_format_international_format(format) : get_format_format(format));\n\n\tif (international) {\n\t\treturn local_to_international_style(formatted_number);\n\t}\n\n\treturn formatted_number;\n}\n\nexport function format_national_number(number, format_as, enforce_national_prefix, country_metadata) {\n\tvar format = choose_format_for_number(get_formats(country_metadata), number);\n\n\tif (!format) {\n\t\treturn number;\n\t}\n\n\treturn format_national_number_using_format(number, format, format_as === 'International', enforce_national_prefix, country_metadata);\n}\n\nexport function choose_format_for_number(available_formats, national_number) {\n\tvar _iteratorNormalCompletion = true;\n\tvar _didIteratorError = false;\n\tvar _iteratorError = undefined;\n\n\ttry {\n\t\tfor (var _iterator = _getIterator(available_formats), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\tvar _format = _step.value;\n\n\t\t\t// Validate leading digits\n\t\t\tif (get_format_leading_digits_patterns(_format).length > 0) {\n\t\t\t\t// The last leading_digits_pattern is used here, as it is the most detailed\n\t\t\t\tvar last_leading_digits_pattern = get_format_leading_digits_patterns(_format)[get_format_leading_digits_patterns(_format).length - 1];\n\n\t\t\t\t// If leading digits don't match then move on to the next phone number format\n\t\t\t\tif (national_number.search(last_leading_digits_pattern) !== 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check that the national number matches the phone number format regular expression\n\t\t\tif (matches_entirely(national_number, new RegExp(get_format_pattern(_format)))) {\n\t\t\t\treturn _format;\n\t\t\t}\n\t\t}\n\t} catch (err) {\n\t\t_didIteratorError = true;\n\t\t_iteratorError = err;\n\t} finally {\n\t\ttry {\n\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t_iterator.return();\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_didIteratorError) {\n\t\t\t\tthrow _iteratorError;\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Removes brackets and replaces dashes with spaces.\n//\n// E.g. \"(999) 111-22-33\" -> \"999 111 22 33\"\n//\nexport function local_to_international_style(local) {\n\treturn local.replace(new RegExp('[' + VALID_PUNCTUATION + ']+', 'g'), ' ').trim();\n}\n\n// Sort out arguments\nfunction sort_out_arguments() {\n\tvar arg_1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\tvar arg_2 = arguments[1];\n\tvar arg_3 = arguments[2];\n\tvar arg_4 = arguments[3];\n\tvar arg_5 = arguments[4];\n\n\tvar input = void 0;\n\tvar format_type = void 0;\n\tvar options = void 0;\n\tvar metadata = void 0;\n\n\t// Sort out arguments.\n\n\t// If the phone number is passed as a string.\n\t// `format('8005553535', ...)`.\n\tif (typeof arg_1 === 'string') {\n\t\t// If country code is supplied.\n\t\t// `format('8005553535', 'RU', 'National', [options], metadata)`.\n\t\tif (typeof arg_3 === 'string') {\n\t\t\t// Will be `parse()`d later in code\n\t\t\tinput = {\n\t\t\t\tphone: arg_1,\n\t\t\t\tcountry: arg_2\n\t\t\t};\n\n\t\t\tformat_type = arg_3;\n\n\t\t\tif (arg_5) {\n\t\t\t\toptions = arg_4;\n\t\t\t\tmetadata = arg_5;\n\t\t\t} else {\n\t\t\t\tmetadata = arg_4;\n\t\t\t}\n\t\t}\n\t\t// Just an international phone number is supplied\n\t\t// `format('+78005553535', 'National', [options], metadata)`.\n\t\telse {\n\t\t\t\t// Will be `parse()`d later in code\n\t\t\t\tinput = {\n\t\t\t\t\tphone: arg_1\n\t\t\t\t};\n\n\t\t\t\tif (typeof arg_2 !== 'string') {\n\t\t\t\t\tthrow new Error('Format type argument not passed for `format()`');\n\t\t\t\t}\n\n\t\t\t\tformat_type = arg_2;\n\n\t\t\t\tif (arg_4) {\n\t\t\t\t\toptions = arg_3;\n\t\t\t\t\tmetadata = arg_4;\n\t\t\t\t} else {\n\t\t\t\t\tmetadata = arg_3;\n\t\t\t\t}\n\t\t\t}\n\t}\n\t// If the phone number is passed as a parsed number object.\n\t// `format({ phone: '8005553535', country: 'RU' }, 'National', [options], metadata)`.\n\telse {\n\t\t\tinput = arg_1;\n\t\t\tformat_type = arg_2;\n\n\t\t\tif (arg_4) {\n\t\t\t\toptions = arg_3;\n\t\t\t\tmetadata = arg_4;\n\t\t\t} else {\n\t\t\t\tmetadata = arg_3;\n\t\t\t}\n\t\t}\n\n\t// Metadata is required.\n\tif (!metadata) {\n\t\tthrow new Error('Metadata is required');\n\t}\n\n\t// Validate `format_type`.\n\tswitch (format_type) {\n\t\tcase 'International':\n\t\tcase 'E.164':\n\t\t// \"International_plaintext\" is deprecated\n\t\tcase 'International_plaintext':\n\t\tcase 'National':\n\t\tcase 'RFC3966':\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new Error('Unknown format type argument passed to \"format()\": \"' + format_type + '\"');\n\t}\n\n\t// Apply default options.\n\tif (options) {\n\t\toptions = _extends({}, default_options, options);\n\t} else {\n\t\toptions = default_options;\n\t}\n\n\treturn { input: input, format_type: format_type, options: options, metadata: metadata };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}